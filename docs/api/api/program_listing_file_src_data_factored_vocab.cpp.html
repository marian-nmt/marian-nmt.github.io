<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File factored_vocab.cpp &mdash; Marian NMT v1.11.5 2022-05-29 documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="canonical" href="http://marian-nmt.github.io/docs/api/api/program_listing_file_src_data_factored_vocab.cpp.html" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Marian NMT
          </a>
              <div class="version">
                v1.11.5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../structure.html">Code Organisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graph.html">Expression graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../operators.html">Operations in the expression graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layer.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factors.html">Using Marian with factors</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_index.html">Library API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">How to contribute to Marian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc_guide.html">Writing documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Marian NMT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Program Listing for File factored_vocab.cpp</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/program_listing_file_src_data_factored_vocab.cpp.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-factored-vocab-cpp">
<span id="program-listing-file-src-data-factored-vocab-cpp"></span><h1>Program Listing for File factored_vocab.cpp<a class="headerlink" href="#program-listing-for-file-factored-vocab-cpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_data_factored_vocab.cpp.html#file-src-data-factored-vocab-cpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/data/factored_vocab.cpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// This is the main implementation of factored models, which are driven by the vocabulary.</span>
<span class="c1">// Decoding, embedding, and output layer call into the vocab to drive their behavior.</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;data/vocab_base.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;common/definitions.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;data/types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;common/regex.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;data/factored_vocab.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;set&gt;</span><span class="cp"></span>

<span class="c1">// @TODO: review all comments and clarify nomenclature:</span>
<span class="c1">// * factor type (e.g. caps: |c* ); currently called a &quot;group&quot;</span>
<span class="c1">// * factor name (e.g. all-caps: |ca )</span>
<span class="c1">// * factor index (e.g. |ca is index 0 inside |ca |ci |cn)</span>
<span class="c1">// * factor unit index (|ca is unit 41324 in joint factor vocab)</span>
<span class="c1">// Also remove references to older outdated versions.</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">marian</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="cm">/*virtual*/</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">FactoredVocab::load</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">modelPath</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">maxSizeUnused</span><span class="w"> </span><span class="cm">/*= 0*/</span><span class="p">)</span><span class="w"> </span><span class="cm">/*override final*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">maxSizeUnused</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// If model has already been loaded, then assume this is a shared object, and skip loading it again.</span>
<span class="w">  </span><span class="c1">// This can be multi-threaded, so must run under lock.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">s_mtx</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">criticalSection</span><span class="p">(</span><span class="n">s_mtx</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//LOG(info, &quot;[vocab] Attempting to load model a second time; skipping (assuming shared vocab)&quot;);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[vocab] Loading vocab spec file {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">modelPath</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// load factor-vocab file and parse it</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">factorMapTokenized</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">line</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">endsWith</span><span class="p">(</span><span class="n">modelPath</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;.fsv&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// @TODO: this extension check is only for backcompat; can be removed once we no longer support the old format</span>
<span class="w">    </span><span class="c1">// this is a fake parser for the generic factor spec, which makes a few hard assumptions:</span>
<span class="w">    </span><span class="c1">//     - all types starting with _ except _has_* are factor names</span>
<span class="w">    </span><span class="c1">//     - X : _x makes surface form X part of prob distribution _x except for _has_*</span>
<span class="w">    </span><span class="c1">//     - X : _has_x adds factor &quot;x&quot; to lemma X</span>
<span class="w">    </span><span class="c1">//     - _x &lt;-&gt; form only allows &quot;_x &lt;-&gt;&quot; or &quot;_x &lt;-&gt; _has_x&quot; (same x), and is otherwise unused</span>
<span class="w">    </span><span class="c1">//     - _lemma is special</span>
<span class="w">    </span><span class="c1">// The current version of the code just converts it internally to the legacy form.</span>
<span class="w">    </span><span class="c1">// @TODO: Once the legacy form is no longer needed, simplify this.</span>
<span class="w">    </span><span class="n">io</span><span class="o">::</span><span class="n">InputFileStream</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="n">modelPath</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">WordIndex</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">factorTypeMap</span><span class="p">;</span><span class="w"> </span><span class="c1">// [type name] -&gt; {factor-type names}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">deferredFactorVocab</span><span class="p">;</span><span class="w"> </span><span class="c1">// factor surface forms are presently expected to be at the end of factorVocab_, so collect them here first</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#if 1 </span><span class="c1">// workaround for a bug fix in FactoredSegmenter that made old .fsv files incompatible</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="w">      </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\xef\xb8\x8f</span><span class="s"> : _lemma _has_wb&quot;</span><span class="p">)</span><span class="w">         </span><span class="c1">// old vocabs have a wrong factor in here</span>
<span class="w">        </span><span class="n">line</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\xef\xb8\x8f</span><span class="s"> : _lemma _has_gl _has_gr&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// patch it to the correct one</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\xef\xb8\x8e</span><span class="s"> : _lemma _has_wb&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">line</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\xef\xb8\x8e</span><span class="s"> : _lemma _has_gl _has_gr&quot;</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">      </span><span class="n">utils</span><span class="o">::</span><span class="n">splitAny</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\t</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tokBuf</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;#&#39;</span><span class="p">)</span><span class="w"> </span><span class="c1">// skip comments and blank lines</span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;_&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// factor name</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">beginsWith</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;_has_&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">fName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// skip _has_</span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factorTypeMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fName</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">factorTypeMap</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Factor trait &#39;{}&#39; requires a factor named &#39;{}&#39; to exist&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">fName</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">tokBuf</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Extraneous characters after factor trait: &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;&lt;-&gt;&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">lhs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;_lemma&quot;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Lemma factor distribution cannot be conditioned: &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">lhs</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&quot;_lemma&quot;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">tokBuf</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&quot;_has&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">lhs</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Factor distribution can only be conditioned on nothing or on _has{}: &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// this declares a new factor</span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">tokBuf</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Extraneous characters after factor declaration: &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lhs</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// skip _</span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factorTypeMap</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fName</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&quot;lemma&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;First factor must be _lemma&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="n">rv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorTypeMap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">fName</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()));</span><span class="w"> </span><span class="c1">// create new factor</span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">.</span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Factor declared twice: &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">groupPrefixes_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">fName</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;lemma&quot;</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;(lemma)&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;|&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fName</span><span class="p">));</span><span class="w"></span>
<span class="w">          </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// if not _ then it is a surface form</span>
<span class="w">        </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Factor-lemma declaration should have the form LEMMA : _FACTOR, _has_FACTOR, _has_FACTOR... in &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">tokBuf</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;_&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Factor name should begin with _ in &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">beginsWith</span><span class="p">(</span><span class="n">tokBuf</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;_has_&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;The first factor after : must not begin with _has_ in &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// add to surface-form dictionary</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// skip _</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">isLemma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fName</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;lemma&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isLemma</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">factorVocab_</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="c1">// note: each item can only be declared once</span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">deferredFactorVocab</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span><span class="w">        </span><span class="c1">// add surface form to its declared factor type</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">surfaceFormSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorTypeMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fName</span><span class="p">);</span><span class="w"> </span><span class="c1">// set of surface forms for this factor</span>
<span class="w">        </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">surfaceFormSet</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">factorTypeMap</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Unknown factor name in &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">rv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">surfaceFormSet</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span><span class="w"> </span><span class="c1">// insert surface form into its declared factor type</span>
<span class="w">        </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">.</span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Factor declared twice: &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">tokenizedMapLine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isLemma</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="c1">// associated factors</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">utils</span><span class="o">::</span><span class="n">beginsWith</span><span class="p">(</span><span class="n">has</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;_has_&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Factor associations must use the form _has_X in &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">isLemma</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Factor associations are only allowed when factor type is _lemma: &#39;{}&#39;, line&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">faName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">has</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// skip _has_ and prepend |</span>
<span class="w">          </span><span class="c1">// for tokenized map, we pick one example of the factor names</span>
<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorTypeMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">faName</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">factorTypeMap</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Invalid factor association {}, no such factor: &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">has</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">factorNames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factorNames</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Factor association {} refers to empty factor type: &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">has</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">oneFactorName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;|&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">factorNames</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="c1">// pick the first entry as one example</span>
<span class="w">          </span><span class="n">tokenizedMapLine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">oneFactorName</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">tokenizedMapLine</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">oneFactorName</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isLemma</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">factorMapTokenized</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tokenizedMapLine</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Malformed .fsv input line {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"> </span><span class="c1">// we only get here for lines we could not process</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">factorTypeName</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">deferredFactorVocab</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">factorVocab_</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;|&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">factorTypeName</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// legacy for old configs</span>
<span class="w">    </span><span class="c1">// legacy format: one factor map, one flat list of factor surface forms</span>
<span class="w">    </span><span class="c1">// load factor vocabulary</span>
<span class="w">    </span><span class="n">factorSeparator_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;@&#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">factorVocabPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">modelPath</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">factorVocabPath</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;l&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// map .fm to .fl</span>
<span class="w">    </span><span class="n">factorVocab_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">factorVocabPath</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">groupPrefixes_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;(lemma)&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;@C&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;@GL&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;@GR&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;@WB&quot;</span><span class="cm">/*, &quot;@WE&quot;*/</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;@CB&quot;</span><span class="cm">/*, &quot;@CE&quot;*/</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// @TODO: hard-coded for these initial experiments</span>
<span class="w">    </span><span class="c1">// @TODO: add checks for empty factor groups until it stops crashing (training already works; decoder still crashes)</span>

<span class="w">    </span><span class="n">io</span><span class="o">::</span><span class="n">InputFileStream</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="n">modelPath</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">WordIndex</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">io</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">utils</span><span class="o">::</span><span class="n">splitAny</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">tokBuf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\t</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">factorMapTokenized</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tokBuf</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// construct mapping tables for factors</span>
<span class="w">  </span><span class="n">constructGroupInfoFromFactorVocab</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">constructFactorIndexConversion</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// parse factorMap</span>
<span class="w">  </span><span class="c1">// modelPath = path to file with entries in order of vocab entries of the form</span>
<span class="w">  </span><span class="c1">//   WORD FACTOR1 FACTOR2 FACTOR3...</span>
<span class="w">  </span><span class="c1">// Factors are grouped</span>
<span class="w">  </span><span class="c1">//  - user specifies list-factor prefixes; all factors beginning with that prefix are in the same group</span>
<span class="w">  </span><span class="c1">//  - factors within a group as multi-class and normalized that way</span>
<span class="w">  </span><span class="c1">//  - groups of size 1 are interpreted as sigmoids, multiply with P(u) / P(u-1)</span>
<span class="w">  </span><span class="c1">//  - one prefix must not contain another</span>
<span class="w">  </span><span class="c1">//  - all factors not matching a prefix get lumped into yet another class (the lemmas)</span>
<span class="w">  </span><span class="c1">//  - factor vocab must be sorted such that all groups are consecutive</span>
<span class="w">  </span><span class="c1">//  - result of Output layer is nevertheless logits, not a normalized probability, due to the sigmoid entries</span>
<span class="w">  </span><span class="c1">// For every lemma, the factor map contains one example. At the end of this loop, we have a vocabulary</span>
<span class="w">  </span><span class="c1">// vocab_ that contains those examples, but not all possible combinations</span>
<span class="w">  </span><span class="n">lemmaHasFactorGroup_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">groupRanges_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">second</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">);</span><span class="w"> </span><span class="c1">// group 0 is the lemmas; this difference is the number of lemma symbols</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numTotalFactors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">WordIndex</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">factorMapTokenized</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tokens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorMapTokenized</span><span class="p">[</span><span class="n">v</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="c1">// parse the line, of the form WORD FACTOR1 FACTOR2 FACTOR1 ...</span>
<span class="w">    </span><span class="c1">// where FACTOR1 is the lemma, a factor that all words have.</span>
<span class="w">    </span><span class="c1">// Not every word has all other factors, so the n-th item is not always in the same factor group.</span>
<span class="w">    </span><span class="c1">// @TODO: change to just use the .wl file, and manually split at @</span>
<span class="w">    </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">tokens</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Factor map must have at least one factor per word&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">modelPath</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">WordIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">factorUnits</span><span class="p">;</span><span class="w"> </span><span class="c1">// units in the joint factor vocab that belong to a specific factor type</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*first factor*/</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorVocab_</span><span class="p">[</span><span class="n">tokens</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span><span class="w"></span>
<span class="w">      </span><span class="n">factorUnits</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// convert to fully unrolled factors representation</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">na</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FACTOR_NOT_APPLICABLE</span><span class="p">;</span><span class="w"> </span><span class="c1">// (gcc compiler bug: sometimes it cannot find this if passed directly)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">(</span><span class="n">groupRanges_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">na</span><span class="p">);</span><span class="w"> </span><span class="c1">// default for unused factors</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">hasFactorGroupFlags</span><span class="p">(</span><span class="n">groupRanges_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">factorUnits</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">factorIndices</span><span class="p">[</span><span class="n">factorGroups_</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorUnit2FactorIndex</span><span class="p">(</span><span class="n">u</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">hasFactorGroupFlags</span><span class="p">[</span><span class="n">factorGroups_</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// record which lemma has what factor groups</span>
<span class="w">    </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">hasFactorGroupFlags</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;Factor map does not specify a lemma (factor of first group) for word {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">front</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lemmaFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lemmaHasFactorGroup_</span><span class="p">[</span><span class="n">factorIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lemmaFlags</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="n">lemmaFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">hasFactorGroupFlags</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">lemmaFlags</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">hasFactorGroupFlags</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Inconsistent factor groups used for word {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">front</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="c1">// map factors to non-dense integer</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factors2word</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// add to vocab (the wordIndex are not dense, so the vocab will have holes)</span>
<span class="w">    </span><span class="c1">// for now add what we get, and then expand more below</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">wordString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word2string</span><span class="p">(</span><span class="n">word</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tokens</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">wordString</span><span class="p">)</span><span class="w"> </span><span class="c1">// order may differ, since we formed the input based on the factors in the user file, which may be in any order</span>
<span class="w">      </span><span class="n">LOG_ONCE</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[vocab] Word name in vocab file {} differs from canonical form {} (this warning is only shown once)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">front</span><span class="p">(),</span><span class="w"> </span><span class="n">wordString</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">vocab_</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">wordString</span><span class="p">,</span><span class="w"> </span><span class="n">word</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">numTotalFactors</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[vocab] Factored-embedding map read with total/unique of {}/{} factors from {} example words (in space of {})&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">numTotalFactors</span><span class="p">,</span><span class="w"> </span><span class="n">factorVocabSize</span><span class="p">(),</span><span class="w"> </span><span class="n">vocab_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="cm">/*numValid()*/</span><span class="p">,</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">withCommas</span><span class="p">(</span><span class="n">virtualVocabSize</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="c1">//vocab_.dumpToFile(modelPath + &quot;_examples&quot;);</span>

<span class="w">  </span><span class="c1">// enumerate all valid combinations of factors for each lemma and add them to vocab_</span>
<span class="w">  </span><span class="c1">// Having vocab_ makes life easier, although it is not strictly needed. Typical expanded valid vocabs</span>
<span class="w">  </span><span class="c1">// are on the order of 200k entries. If we ever go much larger, we&#39;d want to elimimate vocab_</span>
<span class="w">  </span><span class="c1">// and fully virtualize its function.</span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[vocab] Expanding all valid vocab entries out of {}...&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">withCommas</span><span class="p">(</span><span class="n">virtualVocabSize</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">(</span><span class="n">getNumGroups</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">rCompleteVocab</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">,</span><span class="w"> </span><span class="cm">/*g=*/</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[vocab] Completed, total {} valid combinations&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vocab_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="cm">/*numValid()*/</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">//vocab_.dumpToFile(modelPath + &quot;_expanded&quot;);</span>

<span class="cp">#ifdef FACTOR_FULL_EXPANSION</span>
<span class="w">  </span><span class="c1">// create mappings needed for normalization in factored outputs</span>
<span class="w">  </span><span class="n">constructNormalizationInfoForVocab</span><span class="p">();</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="c1">// &lt;/s&gt; and &lt;unk&gt; must exist in the vocabulary</span>
<span class="w">  </span><span class="n">eosId_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Word</span><span class="o">::</span><span class="n">fromWordIndex</span><span class="p">(</span><span class="n">vocab_</span><span class="p">[</span><span class="n">DEFAULT_EOS_STR</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">unkId_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Word</span><span class="o">::</span><span class="n">fromWordIndex</span><span class="p">(</span><span class="n">vocab_</span><span class="p">[</span><span class="n">DEFAULT_UNK_STR</span><span class="p">]);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// LOG(info, &quot;eos: {}; unk: {}, &lt;s&gt;: {}&quot;, word2string(eosId_), word2string(unkId_), vocab_[&quot;&lt;s&gt;&quot;]);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// helper to add missing words to vocab_</span>
<span class="c1">// factorIndices has been formed up to *ex*cluding position [g].</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">FactoredVocab::rCompleteVocab</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// reached the end</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getNumGroups</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factors2word</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">vocab_</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="w"> </span><span class="c1">// add if missing</span>
<span class="w">      </span><span class="n">vocab_</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">word2string</span><span class="p">(</span><span class="n">word</span><span class="p">),</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// try next factor</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">lemmaHasFactorGroup</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">g</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">g1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">factorShape_</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">g1</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">factorIndices</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">rCompleteVocab</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">factorIndices</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FACTOR_NOT_APPLICABLE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">rCompleteVocab</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">size_t</span><span class="w"> </span><span class="nf">FactoredVocab::lemmaSize</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">lemmaSize_</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">FactoredVocab::constructGroupInfoFromFactorVocab</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// form groups</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numGroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groupPrefixes_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">factorVocabSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">factorVocabSize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">factorGroups_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">factorVocabSize</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">groupPrefixes_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">g</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// set group labels; what does not match any prefix will stay in group 0</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">groupPrefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groupPrefixes_</span><span class="p">[</span><span class="n">g</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">WordIndex</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">factorVocabSize</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">beginsWith</span><span class="p">(</span><span class="n">factorVocab_</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="w"> </span><span class="n">groupPrefix</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">//ABORT_IF(factorGroups_[u] != 0, &quot;Factor {} matches multiple groups, incl. {}&quot;, factorVocab_[u], groupPrefix);</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">factorGroups_</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Factor {} matches multiple groups, incl. {}, using {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">factorVocab_</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="w"> </span><span class="n">groupPrefixes_</span><span class="p">[</span><span class="n">factorGroups_</span><span class="p">[</span><span class="n">u</span><span class="p">]],</span><span class="w"> </span><span class="n">groupPrefix</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">factorGroups_</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// determine group index ranges</span>
<span class="w">  </span><span class="n">groupRanges_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">numGroups</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">SIZE_MAX</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="mi">0</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">groupCounts</span><span class="p">(</span><span class="n">numGroups</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// number of group members</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">WordIndex</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">factorVocabSize</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// determine ranges; these must be non-overlapping, verified via groupCounts</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorGroups_</span><span class="p">[</span><span class="n">u</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">groupCounts</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// required by LSH shortlist. Factored segmenter encodes the number of lemmas in the first factor group, this corresponds to actual surface forms</span>
<span class="w">  </span><span class="n">lemmaSize_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groupCounts</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGroups</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// detect non-overlapping groups</span>
<span class="w">    </span><span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[vocab] Factor group &#39;{}&#39; has {} members&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">groupPrefixes_</span><span class="p">[</span><span class="n">g</span><span class="p">],</span><span class="w"> </span><span class="n">groupCounts</span><span class="p">[</span><span class="n">g</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">groupCounts</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// factor group is unused  --@TODO: once this is not hard-coded, this is an error condition</span>
<span class="w">      </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="mi">-1</span><span class="p">].</span><span class="n">second</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// fix up the entry</span>
<span class="w">      </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">second</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">groupCounts</span><span class="p">[</span><span class="n">g</span><span class="p">],</span><span class="w"></span>
<span class="w">             </span><span class="s">&quot;Factor group &#39;{}&#39; members should be consecutive in the factor vocabulary&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">groupPrefixes_</span><span class="p">[</span><span class="n">g</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// we map between factors and flat WordIndex like indexing a tensor</span>
<span class="w">  </span><span class="n">constructFactorIndexConversion</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// create factorShape_ and factorStrides_, for mapping between flat (non-dense) ids and factor arrays</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">FactoredVocab::constructFactorIndexConversion</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shape</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">shape</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">r</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// +1 to reserve the last value for either &quot;factor not used&quot; or &quot;factor not present&quot;</span>
<span class="w">  </span><span class="n">factorShape_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Shape</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">shape</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">factorStrides_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">factorShape_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorStrides_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">factorStrides_</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorStrides_</span><span class="p">[</span><span class="n">g</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">factorShape_</span><span class="p">[</span><span class="n">g</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">((</span><span class="n">WordIndex</span><span class="p">)</span><span class="n">virtualVocabSize</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">virtualVocabSize</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="s">&quot;Too many factors, virtual index space {} exceeds the bit limit of WordIndex type&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">withCommas</span><span class="p">(</span><span class="n">virtualVocabSize</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// encode factors into a Word struct</span>
<span class="c1">// inputs:</span>
<span class="c1">//  - factorIndices[factorType] = factorIndex (e.g. 0 for |ca )</span>
<span class="c1">// output:</span>
<span class="c1">//  - representation as &#39;Word&#39; (which is, in fact, a single big integer)</span>
<span class="n">Word</span><span class="w"> </span><span class="nf">FactoredVocab::factors2word</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">factorIndices</span><span class="w"> </span><span class="cm">/* [numGroups] */</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numGroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getNumGroups</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">numGroups</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Factor indices array size must be same as number of factor groups&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGroups</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">factorIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">[</span><span class="n">g</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">factorIndex</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">FACTOR_NOT_SPECIFIED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// check validity</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">factor0Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">    </span><span class="c1">// lemma</span>
<span class="w">      </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factor0Index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FACTOR_NOT_SPECIFIED</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Without lemma, no other factor may be specified&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">lemmaHasFactorGroup</span><span class="p">(</span><span class="n">factor0Index</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">factorIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FACTOR_NOT_APPLICABLE</span><span class="p">),</span><span class="w"></span>
<span class="w">               </span><span class="s">&quot;Lemma &#39;{}&#39; {} factor group &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">factorVocab_</span><span class="p">[</span><span class="n">WordIndex</span><span class="p">(</span><span class="n">factor0Index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">)],</span><span class="w"></span>
<span class="w">               </span><span class="n">lemmaHasFactorGroup</span><span class="p">(</span><span class="n">factor0Index</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;needs&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;does not have&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">groupPrefixes_</span><span class="p">[</span><span class="n">g</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">factorIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FACTOR_NOT_APPLICABLE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">factorIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FACTOR_NOT_SPECIFIED</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">factorIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">factorShape_</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// sentinel for &quot;unused&quot; or &quot;not specified&quot;</span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factorIndex</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">factorShape_</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Factor index out of range&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">factorIndex</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorStrides_</span><span class="p">[</span><span class="n">g</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Word</span><span class="o">::</span><span class="n">fromWordIndex</span><span class="p">(</span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// encode only a lemma into a &#39;Word&#39;</span>
<span class="c1">// The result is incomplete, in that the lemma likely has additional factors that are not yet specified.</span>
<span class="c1">// Those are encoded as the value FACTOR_NOT_SPECIFIED. This function is used during beam search,</span>
<span class="c1">// which starts with lemma scores, and then adds factors one by one to the path score.</span>
<span class="n">Word</span><span class="w"> </span><span class="nf">FactoredVocab::lemma2Word</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">factor0Index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numGroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getNumGroups</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">factorIndices</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">numGroups</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">factorIndices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">factor0Index</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGroups</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lemmaHasFactorGroup</span><span class="p">(</span><span class="n">factor0Index</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">FACTOR_NOT_SPECIFIED</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">FACTOR_NOT_APPLICABLE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">factorIndices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">factors2word</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// replace a factor that is FACTOR_NOT_SPECIFIED by a specified one</span>
<span class="c1">// This is used in beam search, where factors are searched one after another.</span>
<span class="n">Word</span><span class="w"> </span><span class="nf">FactoredVocab::expandFactoredWord</span><span class="p">(</span><span class="n">Word</span><span class="w"> </span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">groupIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">factorIndex</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//LOG(info, &quot;expand {} + [{}]={}&quot;, word2string(word), groupIndex, factorIndex);</span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">groupIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot add or change lemma in a partial Word&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">isFactorValid</span><span class="p">(</span><span class="n">factorIndex</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Cannot add unspecified or n/a factor to a partial Word&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">word2factors</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">factor0Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">isFactorValid</span><span class="p">(</span><span class="n">factor0Index</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Cannot add factor to a partial Word without lemma&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">[</span><span class="n">groupIndex</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FACTOR_NOT_APPLICABLE</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot add a factor that the lemma does not have&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">[</span><span class="n">groupIndex</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">FACTOR_NOT_SPECIFIED</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot modify a specified factor in a partial Word&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">factorIndices</span><span class="p">[</span><span class="n">groupIndex</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorIndex</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factors2word</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">//LOG(info, &quot;to {}&quot;, word2string(word));</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">word</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// factor unit: index of factor name in the joint factor vocabulary</span>
<span class="c1">// factor index: relative index within factor type, e.g. 0 for |ca</span>
<span class="kt">size_t</span><span class="w"> </span><span class="nf">FactoredVocab::factorUnit2FactorIndex</span><span class="p">(</span><span class="n">WordIndex</span><span class="w"> </span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorGroups_</span><span class="p">[</span><span class="n">u</span><span class="p">];</span><span class="w"> </span><span class="c1">// convert u to relative u within factor group range</span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Invalid factorGroups_ entry??&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// split the &#39;Word&#39; representation, which is really a single big integer, into the individual</span>
<span class="c1">// factor indices for all factor types</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">FactoredVocab::word2factors</span><span class="p">(</span><span class="n">Word</span><span class="w"> </span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">factorIndices</span><span class="w"> </span><span class="cm">/* [numGroups] */</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numGroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getNumGroups</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">factorIndices</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">numGroups</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGroups</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">factorIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getFactor</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">factorIndices</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorIndex</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="cp">#if 1</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factors2word</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">test</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Word &lt;-&gt; factor conversion broken?? {} vs{}, &#39;{}&#39; vs. &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">test</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">(),</span><span class="w"> </span><span class="n">word</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">(),</span><span class="w"> </span><span class="n">word2string</span><span class="p">(</span><span class="n">test</span><span class="p">),</span><span class="w"> </span><span class="n">word2string</span><span class="p">(</span><span class="n">word</span><span class="p">));</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// serialize &#39;Word&#39; representation into its string form</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">FactoredVocab::word2string</span><span class="p">(</span><span class="n">Word</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// this function has some code dup, so that we can bypass some checks for debugging</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">numGroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getNumGroups</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">factor0Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">factorStrides_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGroups</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">factorStrides_</span><span class="p">[</span><span class="n">g</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">factorShape_</span><span class="p">[</span><span class="n">g</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">factorShape_</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// special sentinel value for unspecified or not-applicable</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">factor0Index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">factorShape_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"></span>
<span class="w">        </span><span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;(lemma oob)&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lemmaHasFactorGroup</span><span class="p">(</span><span class="n">factor0Index</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;?&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">getFactorName</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// deserialize factored string form (e.g. HELLO|ci|wb) into its internal binary &#39;Word&#39; representation</span>
<span class="n">Word</span><span class="w"> </span><span class="nf">FactoredVocab::string2word</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">sep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">factorSeparator_</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">parts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">splitAny</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">na</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FACTOR_NOT_APPLICABLE</span><span class="p">;</span><span class="w"> </span><span class="c1">// (gcc compiler bug: sometimes it cannot find this if passed directly)</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">(</span><span class="n">groupRanges_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">na</span><span class="p">);</span><span class="w"> </span><span class="c1">// default for unused factors</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">parts</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">WordIndex</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorVocab_</span><span class="p">.</span><span class="n">tryFind</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sep</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">u</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">logs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">logs</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">logs</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;WARNING: Unknown factor &#39;{}&#39; in &#39;{}&#39;; mapping to &#39;{}&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">word2string</span><span class="p">(</span><span class="n">getUnkId</span><span class="p">()));</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getUnkId</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// convert u to relative u within factor group range</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorGroups_</span><span class="p">[</span><span class="n">u</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Invalid factorGroups_ entry??&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">factorIndices</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factors2word</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">word</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// does a specific factor exist in the vocabulary</span>
<span class="c1">// Factor name must be given without separator. This function cannot be used for lemmas.</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">FactoredVocab::tryGetFactor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">factorName</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">groupIndex</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">factorIndex</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">WordIndex</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">factorVocab_</span><span class="p">.</span><span class="n">tryFind</span><span class="p">(</span><span class="n">factorSeparator_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">factorName</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">groupIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorGroups_</span><span class="p">[</span><span class="n">u</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">groupIndex</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">groupIndex</span><span class="p">].</span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Invalid factorGroups_ entry??&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">factorIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">groupIndex</span><span class="p">].</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// extract the factor index of a given factor type from the &#39;Word&#39; representation</span>
<span class="kt">size_t</span><span class="w"> </span><span class="nf">FactoredVocab::getFactor</span><span class="p">(</span><span class="n">Word</span><span class="w"> </span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">groupIndex</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">factor0Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">factorStrides_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">factorStrides_</span><span class="p">[</span><span class="n">groupIndex</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">factorShape_</span><span class="p">[</span><span class="n">groupIndex</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">factorShape_</span><span class="p">[</span><span class="n">groupIndex</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// special sentinel value for unspecified or not-applicable</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">groupIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">// lemma itself is always applicable, hence &#39;not specified&#39;</span>
<span class="w">      </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FACTOR_NOT_SPECIFIED</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// not lemma: check whether lemma of word has this factor group</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lemmaHasFactorGroup</span><span class="p">(</span><span class="n">factor0Index</span><span class="p">,</span><span class="w"> </span><span class="n">groupIndex</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FACTOR_NOT_SPECIFIED</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FACTOR_NOT_APPLICABLE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// regular value: consistency check if lemma really has this factor group</span>
<span class="w">    </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factor0Index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">factorShape_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Word has specified factor but no lemma??&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">//ABORT_IF(!lemmaHasFactorGroup(factor0Index, groupIndex), &quot;Word has a specified factor for a lemma that does not have that factor group??&quot;);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">lemmaHasFactorGroup</span><span class="p">(</span><span class="n">factor0Index</span><span class="p">,</span><span class="w"> </span><span class="n">groupIndex</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FACTOR_NOT_SPECIFIED</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// @TODO: ^^ needed for determining all valid vocab entries; can we pass a flag in to allow this?</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#ifdef FACTOR_FULL_EXPANSION</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">FactoredVocab::constructNormalizationInfoForVocab</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// create mappings needed for normalization in factored outputs</span>
<span class="w">  </span><span class="c1">//size_t numGroups = groupPrefixes_.size();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">vocabSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virtualVocabSize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">//factorMasks_  .resize(numGroups, std::vector&lt;float&gt;(vocabSize, 0));     // [g][v] 1.0 if word v has factor g</span>
<span class="w">  </span><span class="c1">//factorIndices_.resize(numGroups, std::vector&lt;IndexType&gt;(vocabSize, 0)); // [g][v] index of factor (or any valid index if it does not have it; we use 0)</span>
<span class="w">  </span><span class="n">gapLogMask_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">vocabSize</span><span class="p">,</span><span class="w"> </span><span class="mf">-1e8f</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">WordIndex</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vocabSize</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#if 1 </span><span class="c1">// @TODO: TEST THIS again by disabling factored decoding in beam_search.h</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vocab_</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="n">gapLogMask_</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span><span class="w"> </span><span class="c1">// valid entry</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">factorMap_</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorGroups_</span><span class="p">[</span><span class="n">u</span><span class="p">];</span><span class="w"> </span><span class="c1">// convert u to relative u within factor group range</span>
<span class="w">      </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">second</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Invalid factorGroups_ entry??&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">//factorIndices_[g][v] = (IndexType)(u - groupRanges_[g].first);</span>
<span class="w">      </span><span class="c1">//factorMasks_[g][v] = 1.0f;</span>
<span class="w">      </span><span class="n">gapLogMask_</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span><span class="w"> </span><span class="c1">// valid entry</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">//for (Word v = 0; v &lt; vocabSize; v++) {</span>
<span class="w">  </span><span class="c1">//  LOG(info, &quot;&#39;{}&#39;: {}*{} {}*{} {}*{} {}*{}&quot;, vocab[v],</span>
<span class="w">  </span><span class="c1">//      factorMasks_[0][v], factorIndices_[0][v],</span>
<span class="w">  </span><span class="c1">//      factorMasks_[1][v], factorIndices_[1][v],</span>
<span class="w">  </span><span class="c1">//      factorMasks_[2][v], factorIndices_[2][v],</span>
<span class="w">  </span><span class="c1">//      factorMasks_[3][v], factorIndices_[3][v]);</span>
<span class="w">  </span><span class="c1">//}</span>

<span class="w">  </span><span class="c1">// create the global factor matrix, which is used for getLogits() only</span>
<span class="w">  </span><span class="c1">// For invalid words, this leaves empty matrix rows, which are later masked by adding gapLogMask.</span>
<span class="w">  </span><span class="n">Words</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vocabSize</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="c1">// note: this loops over the entire vocab space, incl. gaps</span>
<span class="w">    </span><span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Word</span><span class="o">::</span><span class="n">fromWordIndex</span><span class="p">(</span><span class="n">v</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">globalFactorMatrix_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csr_rows</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"> </span><span class="c1">// [V x U]</span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cm">/*virtual*/</span><span class="w"> </span><span class="n">Word</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="k">operator</span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="cm">/*override final*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// @TODO: do away with vocab_ altogether, and just always parse.</span>
<span class="w">  </span><span class="n">WordIndex</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vocab_</span><span class="p">.</span><span class="n">tryFind</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Word</span><span class="o">::</span><span class="n">fromWordIndex</span><span class="p">(</span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">string2word</span><span class="p">(</span><span class="n">word</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*virtual*/</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="k">operator</span><span class="p">[](</span><span class="n">Word</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="cm">/*override final*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//LOG(info, &quot;Looking up Word {}={}&quot;, word.toWordIndex(), word2string(word));</span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">vocab_</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">()),</span><span class="w"> </span><span class="s">&quot;Invalid factor combination {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">word2string</span><span class="p">(</span><span class="n">word</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">vocab_</span><span class="p">[</span><span class="n">word</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">()];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// convert a string representation of a token sequence to all-caps by changing all capitalization factors to |ca</span>
<span class="cm">/*virtual*/</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">toUpper</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="cm">/*override final*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">findReplace</span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">findReplace</span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">findReplace</span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">findReplace</span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">findReplace</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|scl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|scu&quot;</span><span class="p">,</span><span class="w"> </span><span class="cm">/*all=*/</span><span class="nb">true</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;|ci&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|ca&quot;</span><span class="p">,</span><span class="w"> </span><span class="cm">/*all=*/</span><span class="nb">true</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;|cn&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|ca&quot;</span><span class="p">,</span><span class="w"> </span><span class="cm">/*all=*/</span><span class="nb">true</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;@CI&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;@CA&quot;</span><span class="p">,</span><span class="w"> </span><span class="cm">/*all=*/</span><span class="nb">true</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;@CN&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;@CA&quot;</span><span class="p">,</span><span class="w"> </span><span class="cm">/*all=*/</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// convert a string representation of a token sequence to English title case by changing the capitalization factors to |ci</span>
<span class="cm">/*virtual*/</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">toEnglishTitleCase</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">line</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="cm">/*override final*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// @BUGBUG: does not handle the special words that should remain lower-case</span>
<span class="w">  </span><span class="c1">// note: this presently supports both @WB and @GL- (legacy)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">findReplace</span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">findReplace</span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">findReplace</span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">findReplace</span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">findReplace</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|scl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|scu&quot;</span><span class="p">,</span><span class="w"> </span><span class="cm">/*all=*/</span><span class="nb">true</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;|cn|wb&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|ci|wb&quot;</span><span class="p">,</span><span class="w"> </span><span class="cm">/*all=*/</span><span class="nb">true</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;|cn|gl-&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|ci|gl-&quot;</span><span class="p">,</span><span class="w"> </span><span class="cm">/*all=*/</span><span class="nb">true</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;@CN@WB&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;@CI@WB&quot;</span><span class="p">,</span><span class="w"> </span><span class="cm">/*all=*/</span><span class="nb">true</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;@CN@GL-&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;@CI@GL-&quot;</span><span class="p">,</span><span class="w"> </span><span class="cm">/*all=*/</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// convert word indices to indices of shortlist items</span>
<span class="c1">// We only shortlist the lemmas, hence return the lemma index (offset to correctly index into the concatenated W matrix).</span>
<span class="c1">// This strange pointer-based interface is for ease of interaction with our production environment.</span>
<span class="cm">/*virtual*/</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">transcodeToShortlistInPlace</span><span class="p">(</span><span class="n">WordIndex</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">num</span><span class="o">--</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Word</span><span class="o">::</span><span class="n">fromWordIndex</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lemmaIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getFactor</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">WordIndex</span><span class="p">)</span><span class="n">lemmaIndex</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// generate a valid random factored word (used by collectStats())</span>
<span class="cm">/*virtual*/</span><span class="w"> </span><span class="n">Word</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">randWord</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="cm">/*override final*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">numGroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getNumGroups</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">;</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">numGroups</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGroups</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">factorIndex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">lemmaHasFactorGroup</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">g</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="n">factorIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">factorShape_</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="n">factorIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FACTOR_NOT_APPLICABLE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">factorIndices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">factorIndex</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">factors2word</span><span class="p">(</span><span class="n">factorIndices</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// encode a string representation of an entire token sequence, as found in the corpus file, into a &#39;Word&#39; array</span>
<span class="cm">/*virtual*/</span><span class="w"> </span><span class="n">Words</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">encode</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">addEOS</span><span class="w"> </span><span class="cm">/*= true*/</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="cm">/*inference*/</span><span class="w"> </span><span class="cm">/*= false*/</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="cm">/*override final*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lineTokens</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">utils</span><span class="o">::</span><span class="n">split</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">lineTokens</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">Words</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">lineTokens</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">addEOS</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">tok</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">lineTokens</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">tok</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">addEOS</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getEosId</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// decode a &#39;Word&#39; array into the external string representation of that token sequence, as written to output files</span>
<span class="cm">/*virtual*/</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">decode</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Words</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sentence</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ignoreEOS</span><span class="w"> </span><span class="cm">/*= true*/</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="cm">/*override final*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">decoded</span><span class="p">;</span><span class="w"> </span><span class="n">decoded</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">sentence</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sentence</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">w</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">getEosId</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">ignoreEOS</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="n">decoded</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">w</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">decoded</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// diagnostics version of decode() that will not fail on partial words, will print EOS, and is a little slower</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">decodeForDiagnostics</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Words</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sentence</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">decoded</span><span class="p">;</span><span class="w"> </span><span class="n">decoded</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">sentence</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sentence</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">decoded</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">word2string</span><span class="p">(</span><span class="n">w</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">decoded</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// helper to unescape \x.. and \u....</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">unescapeHexEscapes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">utf8Lemma</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">utf8Lemma</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;\\&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="c1">// nothing to do</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lemma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">utf8ToUtf16String</span><span class="p">(</span><span class="n">utf8Lemma</span><span class="p">);</span><span class="w"> </span><span class="c1">// \u.... implies we must operate on UTF-16 level (not UCS-4)</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lemma</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;\\&#39;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">lemma</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">lemma</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;x&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">lemma</span><span class="p">[</span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;u&#39;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Malformed escape in factored encoding: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">utf8Lemma</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numDigits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">lemma</span><span class="p">[</span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;u&#39;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 2 for \x, 4 for \u</span>
<span class="w">    </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">numDigits</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">lemma</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Malformed escape in factored encoding: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">utf8Lemma</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">digits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">utf8FromUtf16String</span><span class="p">(</span><span class="n">lemma</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">numDigits</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">strtoul</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">lemma</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char16_t</span><span class="p">)</span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">lemma</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">numDigits</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lemma</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;\\&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">utf8Lemma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">utf8FromUtf16String</span><span class="p">(</span><span class="n">lemma</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// convert a &#39;Word&#39; sequence to its final human-readable surface form</span>
<span class="c1">// This interprets the capitalization and glue factors.</span>
<span class="c1">// This assumes a specific notation of factors, emulating our C# code for generating these factors:</span>
<span class="c1">//  - | as separator symbol</span>
<span class="c1">//  - capitalization factors are cn, ci, and ca</span>
<span class="c1">//  - glue factors are gl+, gr+, wbn, wen, cbn, cen</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">surfaceForm</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Words</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sentence</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="cm">/*override final*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">res</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">sentence</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">prevHadGlueRight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// no space at sentence start</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sentence</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getEosId</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">w</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tokens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">split</span><span class="p">(</span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">//std::cerr &lt;&lt; token &lt;&lt; &quot; &quot;;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lemma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tokenSet</span><span class="p">(</span><span class="n">tokens</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tokens</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">factor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tokenSet</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tokenSet</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="c1">// spacing</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">hasGlueRight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">has</span><span class="p">(</span><span class="s">&quot;gr+&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">has</span><span class="p">(</span><span class="s">&quot;wen&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">has</span><span class="p">(</span><span class="s">&quot;cen&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">hasGlueLeft</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">has</span><span class="p">(</span><span class="s">&quot;gl+&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">has</span><span class="p">(</span><span class="s">&quot;wbn&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">has</span><span class="p">(</span><span class="s">&quot;cbn&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">has</span><span class="p">(</span><span class="s">&quot;wi&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">insertSpaceBefore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">prevHadGlueRight</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">hasGlueLeft</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">insertSpaceBefore</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">prevHadGlueRight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hasGlueRight</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// capitalization</span>
<span class="w">    </span><span class="n">unescapeHexEscapes</span><span class="p">(</span><span class="n">lemma</span><span class="p">);</span><span class="w"> </span><span class="c1">// unescape \x.. and \u....</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">utils</span><span class="o">::</span><span class="n">beginsWith</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\xE2\x96\x81</span><span class="s">&quot;</span><span class="p">))</span><span class="w">  </span><span class="c1">// remove leading _ (\u2581, for DistinguishInitialAndInternalPieces mode)</span>
<span class="w">        </span><span class="n">lemma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lemma</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w">      </span><span class="p">(</span><span class="n">has</span><span class="p">(</span><span class="s">&quot;ci&quot;</span><span class="p">))</span><span class="w">  </span><span class="n">lemma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">utf8Capitalized</span><span class="p">(</span><span class="n">lemma</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">has</span><span class="p">(</span><span class="s">&quot;ca&quot;</span><span class="p">))</span><span class="w">  </span><span class="n">lemma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">utf8ToUpper</span><span class="w">    </span><span class="p">(</span><span class="n">lemma</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">has</span><span class="p">(</span><span class="s">&quot;cn&quot;</span><span class="p">))</span><span class="w">  </span><span class="n">lemma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">utf8ToLower</span><span class="w">    </span><span class="p">(</span><span class="n">lemma</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">has</span><span class="p">(</span><span class="s">&quot;scu&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">lemma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">utf8ToUpper</span><span class="w">    </span><span class="p">(</span><span class="n">lemma</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">has</span><span class="p">(</span><span class="s">&quot;scl&quot;</span><span class="p">))</span><span class="w"> </span><span class="n">lemma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">utf8ToLower</span><span class="w">    </span><span class="p">(</span><span class="n">lemma</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">lemma</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">//std::cerr &lt;&lt; &quot;\n&quot; &lt;&lt; res &lt;&lt; &quot;\n&quot;;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">size_t</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">getTotalFactorCount</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">factorVocabSize</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">lemmaAndFactorsIndexes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Words</span><span class="o">&amp;</span><span class="w"> </span><span class="n">words</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">lemmaIndices</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">lemmaIndices</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">factorIndices</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">getTotalFactorCount</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">numGroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getNumGroups</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lemmaAndFactorIndices</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">word</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">words</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vocab_</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// skip invalid combinations in the space (can only happen during initialization)  --@TODO: add a check?</span>
<span class="w">      </span><span class="n">word2factors</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">lemmaAndFactorIndices</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">lemmaIndices</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="n">IndexType</span><span class="p">)</span><span class="w"> </span><span class="n">lemmaAndFactorIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="c1">// save the lemma vocabulary index</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGroups</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// loop over the different factors group</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">factorIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lemmaAndFactorIndices</span><span class="p">[</span><span class="n">g</span><span class="p">];</span><span class="w"> </span><span class="c1">// get the vocabulary index of the factor of group g</span>
<span class="w">        </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factorIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FACTOR_NOT_SPECIFIED</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Attempted to embed a word with a factor not specified&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">factorShape_</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// loop over all factors in group g</span>
<span class="w">          </span><span class="n">factorIndices</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">factorIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">i</span><span class="p">));</span><span class="w"> </span><span class="c1">// fill the factor indexes array with &#39;0&#39; if the factor is not used in a given word, &#39;1&#39; if it is</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// create a CSR matrix M[V,U] from words[] with M[v,u] = 1 if factor u is a factor of word v</span>
<span class="c1">// This is used to form the embedding of a multi-factor token.</span>
<span class="c1">// That embedding is a sum of the embeddings of the individual factors.</span>
<span class="c1">// Those individual embeddings are assumed to be concatenated into one joint large embedding matrix.</span>
<span class="c1">// The factor embeddings are summed up by multiplying the joint embedding matrix with a sparse matrix</span>
<span class="c1">// that contains a 1 for all positions in the joint matrix that should be summed up.</span>
<span class="c1">// This function creates that sparse matrix in CSR form.</span>
<span class="n">FactoredVocab</span><span class="o">::</span><span class="n">CSRData</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">csr_rows</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Words</span><span class="o">&amp;</span><span class="w"> </span><span class="n">words</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">numGroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getNumGroups</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">weights</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">indices</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">offsets</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">offsets</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">indices</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// (at least this many)</span>
<span class="w">  </span><span class="c1">// loop over all input words, and select the corresponding set of unit indices into CSR format</span>
<span class="w">  </span><span class="n">offsets</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="n">IndexType</span><span class="p">)</span><span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">words</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vocab_</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">toWordIndex</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// skip invalid combinations in the space (can only happen during initialization)  --@TODO: add a check?</span>
<span class="w">      </span><span class="n">word2factors</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGroups</span><span class="p">;</span><span class="w"> </span><span class="n">g</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// @TODO: make this faster by having a list of all factors to consider for a lemma?</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">factorIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factorIndices</span><span class="p">[</span><span class="n">g</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">factorIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FACTOR_NOT_SPECIFIED</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Attempted to embed a word with a factor not specified&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">factorIndex</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FACTOR_NOT_APPLICABLE</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">indices</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="n">IndexType</span><span class="p">)(</span><span class="n">factorIndex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">groupRanges_</span><span class="p">[</span><span class="n">g</span><span class="p">].</span><span class="n">first</span><span class="p">));</span><span class="w"> </span><span class="c1">// map to unit index</span>
<span class="w">        </span><span class="n">weights</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">offsets</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="n">IndexType</span><span class="p">)</span><span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// next matrix row begins at this offset</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Shape</span><span class="p">({(</span><span class="kt">int</span><span class="p">)</span><span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">factorVocabSize</span><span class="p">()}),</span><span class="w"> </span><span class="n">weights</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="n">offsets</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Helper to construct and load a FactordVocab from a path is given (non-empty) and if it specifies a factored vocab.</span>
<span class="c1">// This is used by the Embedding and Output layers.</span>
<span class="cm">/*static*/</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">FactoredVocab</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">tryCreateAndLoad</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">FactoredVocab</span><span class="o">&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">static_pointer_cast</span><span class="o">&lt;</span><span class="n">FactoredVocab</span><span class="o">&gt;</span><span class="p">(</span><span class="n">createFactoredVocab</span><span class="p">(</span><span class="n">path</span><span class="p">));</span><span class="w"> </span><span class="c1">// this checks the file extension</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">res</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">);</span><span class="w"> </span><span class="c1">// or throw</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// WordLUT</span>
<span class="n">WordIndex</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">WordLUT</span><span class="o">::</span><span class="n">add</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">WordIndex</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Attempted to add the empty word to a dictionary&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">wasInserted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str2index_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">)).</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">wasInserted</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Duplicate vocab entry for &#39;{}&#39;, new index {} vs. existing index {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">str2index_</span><span class="p">[</span><span class="n">word</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">wasInserted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index2str_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">word</span><span class="p">)).</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">wasInserted</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Duplicate vocab entry for index {} (new: &#39;{}&#39;; existing: &#39;{}&#39;)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">index2str_</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">g_emptyString</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">WordLUT</span><span class="o">::</span><span class="k">operator</span><span class="p">[](</span><span class="n">WordIndex</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index2str_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">index2str_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="c1">// returns an empty string for unknown index values</span>
<span class="w">    </span><span class="c1">// @TODO: is that ever used ? If so, document.If not, remove this feature and let it fail.static const std::string g_emptyString;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">g_emptyString</span><span class="p">;</span><span class="w"> </span><span class="c1">// (using a global since we return a reference)</span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">WordIndex</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">WordLUT</span><span class="o">::</span><span class="k">operator</span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str2index_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">word</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">str2index_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;Token &#39;{}&#39; not found in vocabulary&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">word</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">WordLUT</span><span class="o">::</span><span class="n">tryFind</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">word</span><span class="p">,</span><span class="w"> </span><span class="n">WordIndex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str2index_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">word</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">str2index_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">WordLUT</span><span class="o">::</span><span class="n">load</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">line</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="o">::</span><span class="n">InputFileStream</span><span class="w"> </span><span class="nf">in</span><span class="p">(</span><span class="n">path</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">WordIndex</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">io</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">add</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">WordLUT</span><span class="o">::</span><span class="n">dumpToFile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">path</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">io</span><span class="o">::</span><span class="n">OutputFileStream</span><span class="w"> </span><span class="nf">out</span><span class="p">(</span><span class="n">path</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">kvp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">index2str_</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">out</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">kvp</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">withCommas</span><span class="p">(</span><span class="n">kvp</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">exts</span><span class="p">{</span><span class="w"> </span><span class="s">&quot;.fsv&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;.fm&quot;</span><span class="cm">/*legacy*/</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// @TODO: delete the legacy one</span>

<span class="c1">// Note: This does not actually load it, only checks the path for the type.</span>
<span class="c1">// Since loading takes a while, we cache instances.</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">IVocab</span><span class="o">&gt;</span><span class="w"> </span><span class="n">createFactoredVocab</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vocabPath</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// this can be multi-threaded, so must run under lock</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">s_mtx</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">criticalSection</span><span class="p">(</span><span class="n">s_mtx</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">isFactoredVocab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">any_of</span><span class="p">(</span><span class="n">exts</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">exts</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">utils</span><span class="o">::</span><span class="n">endsWith</span><span class="p">(</span><span class="n">vocabPath</span><span class="p">,</span><span class="w"> </span><span class="n">ext</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isFactoredVocab</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">IVocab</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">s_cache</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s_cache</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">vocabPath</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">s_cache</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">LOG_ONCE</span><span class="p">(</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[vocab] Reusing existing vocabulary object in memory (vocab size {})&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">vocab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">New</span><span class="o">&lt;</span><span class="n">FactoredVocab</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">s_cache</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">vocabPath</span><span class="p">,</span><span class="w"> </span><span class="n">vocab</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">vocab</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cm">/*virtual*/</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">FactoredVocab</span><span class="o">::</span><span class="n">suffixes</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="cm">/*override final*/</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">exts</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w">  </span><span class="c1">// namespace marian</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Marian NMT Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>