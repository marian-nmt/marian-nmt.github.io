

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Program Listing for File expression_graph_onnx_serialization.cpp &mdash; Marian NMT v1.10.3 2021-03-22 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  

  
  

  
    <link rel="canonical" href="http://marian-nmt.github.io/docs/api/api/program_listing_file_src_onnx_expression_graph_onnx_serialization.cpp.html" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Marian NMT
          

          
          </a>

          
            
            
              <div class="version">
                v1.10.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../graph.html">Expression graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../operators.html">Operations in the Expression Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_index.html">Library API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">How to contribute to Marian</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Marian NMT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Program Listing for File expression_graph_onnx_serialization.cpp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/api/program_listing_file_src_onnx_expression_graph_onnx_serialization.cpp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-expression-graph-onnx-serialization-cpp">
<span id="program-listing-file-src-onnx-expression-graph-onnx-serialization-cpp"></span><h1>Program Listing for File expression_graph_onnx_serialization.cpp<a class="headerlink" href="#program-listing-for-file-expression-graph-onnx-serialization-cpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_onnx_expression_graph_onnx_serialization.cpp.html#file-src-onnx-expression-graph-onnx-serialization-cpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/onnx/expression_graph_onnx_serialization.cpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef USE_ONNX</span>

<span class="cp">#include</span> <span class="cpf">&quot;onnx/expression_graph_onnx_exporter.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graph/expression_operators.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graph/node_operators_unary.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graph/node_operators_binary.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;common/version.h&quot;</span><span class="cp"></span>
<span class="cp">#define AuxillaryParseTableField AuxiliaryParseTableField  </span><span class="c1">// in protobuf 3.12, the generated source has a spelling error</span>
<span class="cp">#include</span> <span class="cpf">&quot;3rd_party/onnx/protobuf/onnx-ml.pb-wrapper.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">marian</span> <span class="p">{</span>

  <span class="c1">// collection of helper functions for accessing and converting Expr properties</span>
  <span class="c1">// This class is a friend of all node-op classes whose attributes we need to access.</span>
  <span class="k">class</span> <span class="nc">SerializationHelpers</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="c1">// helper for accessing class members in Marian&#39;s polymorphic node classes</span>
    <span class="c1">// If &#39;e&#39; is of NNaryNodeOp then execute getFn() and return true.</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">F</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetAttributes</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="n">F</span><span class="o">&amp;</span> <span class="n">getFn</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">np</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">dynamic_pointer_cast</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">getFn</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetScalarAttribute</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">scalar</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tryGetAttributes</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span> <span class="n">scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scalar_</span><span class="p">;</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetMatMulAttributes</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">transA</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">transB</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">scalar</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tryGetAttributes</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">transA</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">transA_</span><span class="p">;</span>
        <span class="n">transB</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">transB_</span><span class="p">;</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scalar_</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetEpsilonAttribute</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">eps</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tryGetAttributes</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">eps_</span><span class="p">;</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetAxisAttribute</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">axis</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tryGetAttributes</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span> <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">axis</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">axis_</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetAxesAttribute</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&amp;</span> <span class="n">axes</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tryGetAttributes</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">axes</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">ax</span> <span class="p">:</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">axes_</span><span class="p">)</span>
          <span class="n">axes</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">axis</span><span class="p">(</span><span class="n">ax</span><span class="p">));</span>
      <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetShiftAttributes</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">shift</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">padValue</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tryGetAttributes</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shift</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">shift_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">shift_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="n">padValue</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">padValue_</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetSliceAttribute</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">slice</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tryGetAttributes</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span> <span class="n">slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">slice_</span><span class="p">;</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetReshapeeAttributePtr</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="o">*&amp;</span> <span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tryGetAttributes</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span> <span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">reshapee_</span><span class="p">;</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetStepNodeAttributePtr</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="o">*&amp;</span> <span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tryGetAttributes</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span> <span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">stepNode_</span><span class="p">;</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">NNaryNodeOp</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">tryGetMaskAttributePtr</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="o">*&amp;</span> <span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tryGetAttributes</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">NNaryNodeOp</span><span class="o">&gt;</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span> <span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">mask_</span><span class="p">;</span> <span class="p">});</span>
    <span class="p">}</span>

    <span class="c1">// call this for mandatory parameters, e.g. tryGetMaskAttributePtr(...) || tryFailed(&quot;message&quot;, ...)</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">fail</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ABORT</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">fail</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">fail</span><span class="p">(</span><span class="s">&quot;an attempt to access a Marian node attribute unexpectedly failed due to a type mismatch&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="p">};</span>
  <span class="k">using</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SerializationHelpers</span><span class="p">;</span>

  <span class="k">struct</span> <span class="nc">InputsMap</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">Expr</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="c1">// redirect input if found</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">end</span><span class="p">())</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">e</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// helper for rebuildNodesForward()</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">addNodeAndChildren</span><span class="p">(</span><span class="n">Expr</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;&amp;</span> <span class="n">nodesForward</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;&amp;</span> <span class="n">visited</span><span class="p">,</span> <span class="k">const</span> <span class="n">InputsMap</span><span class="o">&amp;</span> <span class="n">inputsMap</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// check if this is an input</span>
    <span class="c1">// In that case, we generate a replacement node instead, which has no children and thus terminates the recursion.</span>
    <span class="c1">// All nodes that reference this input are, however, unmodified.</span>
    <span class="c1">// The tape is now inconsistent. The consumer of this tape must perform child mapping.</span>
    <span class="k">auto</span> <span class="n">replacementNode</span> <span class="o">=</span> <span class="n">inputsMap</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">replacementNode</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">replacementNode</span><span class="p">;</span>
    <span class="c1">// recursion terminates if we already visited a node</span>
    <span class="c1">// (Input mapping is taken into account already.)</span>
    <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">visited</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="c1">// already in visited set: done</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">child</span> <span class="p">:</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">())</span> <span class="c1">// children come before node itself</span>
      <span class="n">addNodeAndChildren</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">nodesForward</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">inputsMap</span><span class="p">);</span>
    <span class="n">nodesForward</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// rebuild nodesForward_ from a graph given by its set of roots</span>
  <span class="c1">// Also replaces the inputs by constants, but does not redirect references (leaving an invalid tape--must be corrected on the fly by the caller!).</span>
  <span class="kt">void</span> <span class="n">ExpressionGraphONNXExporter</span><span class="o">::</span><span class="n">rebuildNodesForward</span><span class="p">(</span><span class="k">const</span> <span class="n">InputsMap</span><span class="o">&amp;</span> <span class="n">inputsMap</span><span class="p">,</span>
                                                        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Expr</span><span class="o">&gt;&gt;&amp;</span> <span class="n">outputDefs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">nodesForward_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">outputDef</span> <span class="p">:</span> <span class="n">outputDefs</span><span class="p">)</span>
      <span class="n">addNodeAndChildren</span><span class="p">(</span><span class="n">outputDef</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="n">nodesForward_</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">inputsMap</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">class</span> <span class="nc">NodeReferenceRedirector</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="o">&gt;</span> <span class="n">nodeMap</span><span class="p">;</span> <span class="c1">// [orig node] -&gt; replacement nodes</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">addRedirect</span><span class="p">(</span><span class="k">const</span> <span class="n">Expr</span><span class="o">&amp;</span> <span class="n">whichNode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Expr</span><span class="o">&amp;</span> <span class="n">withWhichNode</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">nodeMap</span><span class="p">[</span><span class="n">whichNode</span><span class="p">]</span> <span class="o">=</span> <span class="n">withWhichNode</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// in-place redirect an Expr reference, i.e. look up the redirect and replace the original with it</span>
    <span class="kt">void</span> <span class="n">redirectReference</span><span class="p">(</span><span class="n">Expr</span><span class="o">&amp;</span> <span class="n">child</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">nodeMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">nodeMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>       <span class="c1">// redirect child to the replacement node</span>
        <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">nodeMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nodeMap</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">&quot;Nested macro expansion??&quot;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// redirect all references (=children and more in special cases)</span>
    <span class="kt">void</span> <span class="nf">redirectAllReferencesIn</span><span class="p">(</span><span class="n">Expr</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="c1">// redirect all children</span>
      <span class="k">auto</span><span class="o">&amp;</span> <span class="n">children</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">();</span> <span class="c1">// this is a mutable reference</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">child</span> <span class="p">:</span> <span class="n">children</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// child is a mutable reference</span>
        <span class="n">redirectReference</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// redirect additional references tat some nodes hold</span>
      <span class="n">Expr</span><span class="o">*</span> <span class="n">ep</span><span class="p">{};</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="o">::</span><span class="n">tryGetReshapeeAttributePtr</span><span class="o">&lt;</span><span class="n">ReshapeNodeOp</span><span class="o">&gt;</span>   <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ep</span><span class="p">)</span> <span class="o">||</span>
          <span class="c1">//E::tryGetStepNodeAttributePtr&lt;StepNodeOp&gt;      (v, ep) ||    // @TODO: review all of these and update the names</span>
          <span class="n">E</span><span class="o">::</span><span class="n">tryGetMaskAttributePtr</span><span class="o">&lt;</span><span class="n">PoolingWithMaskingOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ep</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">redirectReference</span><span class="p">(</span><span class="o">*</span><span class="n">ep</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">Expr</span> <span class="n">newConstant</span><span class="p">(</span><span class="n">Expr</span> <span class="n">v</span><span class="p">,</span> <span class="n">Shape</span> <span class="n">shape</span><span class="p">,</span> <span class="kt">float</span> <span class="n">val</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">suffix</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">constant</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">inits</span><span class="o">::</span><span class="n">fromVector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">shape</span><span class="p">.</span><span class="n">elements</span><span class="p">(),</span> <span class="n">val</span><span class="p">)));</span>
    <span class="n">expr</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="s">&quot;const_&quot;</span> <span class="o">+</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">())</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">);</span>
    <span class="c1">// Note: By convention, all constants should be named const_ something (and all data inputs data_),</span>
    <span class="c1">// to distinguish them from trainable weight tensors.</span>
    <span class="k">return</span> <span class="n">expr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// unroll higher-level operations for which no ONNX equivalent exists</span>
  <span class="c1">// This updates the functionDefs&#39; root nodes in-place.</span>
  <span class="c1">// Note: This appends to nodesForward_ in-place. Some meta-information, like root node, is not updated correctly.</span>
  <span class="kt">void</span> <span class="n">ExpressionGraphONNXExporter</span><span class="o">::</span><span class="n">expandMacroOpsForONNX</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Expr</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">Expr</span><span class="o">&gt;&gt;</span> <span class="o">&gt;&gt;&amp;</span> <span class="n">functionDefs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;[graph] Expanding macro ops into primitives. Current graph size is {}&quot;</span><span class="p">,</span> <span class="n">nodesForward_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">NodeReferenceRedirector</span> <span class="n">nodeReferenceRedirector</span><span class="p">;</span>
    <span class="c1">// clear memoization cache, as it removes some children for ops that have not changed since last inference</span>
    <span class="n">tensors_</span><span class="o">-&gt;</span><span class="n">clearLongtermMemory</span><span class="p">();</span>
    <span class="c1">// Note: expansions will add to the existing tape in-place. But we disallows nested expansions,</span>
    <span class="c1">// i.e. disallow looping over newly created nodes, because otherwise the nodeReferenceRedirector</span>
    <span class="c1">// becomes very complicated because those new nodes are no longer topo-sorted.</span>
    <span class="c1">// The for loop below loops also over newly-created nodes, but those may not</span>
    <span class="c1">// trigger another expansion, which will be caught in redirectReference() above.</span>
    <span class="k">auto</span> <span class="n">beg</span> <span class="o">=</span> <span class="n">nodesForward_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nodesForward_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">vi</span> <span class="o">=</span> <span class="n">beg</span><span class="p">;</span> <span class="n">vi</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">vi</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">vi</span><span class="p">;</span>
      <span class="c1">// redirect all children of this node, in case they got mapped in this process</span>
      <span class="n">nodeReferenceRedirector</span><span class="p">.</span><span class="n">redirectAllReferencesIn</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
      <span class="c1">// expand macro ops</span>
      <span class="n">Expr</span> <span class="n">n</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"> // For GC ONNX, some ops are still missing. Map these first.</span>
<span class="c">      // @BUGBUG: These operators are not up-to-date</span>
<span class="c">      if (v-&gt;type() == &quot;highway&quot;) {</span>
<span class="c">        // Replace Sigmoid by Softmax. The only sigmoid in the system comes from highway.</span>
<span class="c">        auto y = v-&gt;child(0);       // something like [B, H, T, dim]</span>
<span class="c">        auto x = v-&gt;child(1);</span>
<span class="c">        auto t = v-&gt;child(2);</span>
<span class="c">        auto shape = x-&gt;shape();</span>
<span class="c">        ABORT_IF(y-&gt;shape() != shape || t-&gt;shape() != shape, &quot;unexpected highway shapes??&quot;);</span>
<span class="c">        // Softmax([x,0]) = (Sigmoid(x), 1-Sigmoid(x))</span>
<span class="c">        // Softmax([x,y]) = e^x / (e^x + e^y)</span>
<span class="c">        // Sigmoid(x) = e^x / (e^x + e^0)</span>
<span class="c">        auto shape1 = Shape{shape.elements() / shape.back(), shape.back(), 1};</span>
<span class="c">        t = reshape(t, shape1);</span>
<span class="c">        auto tAug = concatenate({t, newConstant(v, t-&gt;shape(), 0.0f, &quot;zero_row&quot;)}, -1); // [(B*H*T, dim, 2)]</span>
<span class="c">        auto s = softmax(tAug, /*axis=*/-1); // = (Sigmoid(t), 1-Sigmoid(t)) : [(B*H*T, dim, 2)]</span>
<span class="c">        s = swapAxes(s, 0, -1);              // step() only supports axis=0</span>
<span class="c">        auto sy = step(s, 0, /*axis=*/0);</span>
<span class="c">        auto sx = step(s, 1, /*axis=*/0);</span>
<span class="c">        sy = swapAxes(sy, 0, -1);</span>
<span class="c">        sx = swapAxes(sx, 0, -1);</span>
<span class="c">        sy = reshape(sy, shape);</span>
<span class="c">        sx = reshape(sx, shape);</span>
<span class="c">        n = sy * y + sx * x;</span>
<span class="c">        //LOG(info, &quot;OVERWRITING highway, {} -&gt; {} -&gt; {} -&gt; back&quot;, std::string(shape), std::string(shape1), std::string(tAug-&gt;shape()));</span>
<span class="c">      }</span>
<span class="c">      else if (v-&gt;type() == &quot;sum&quot;) {</span>
<span class="c">        // replace ReduceSum by a matrix product with a vector of ones</span>
<span class="c">        auto x = v-&gt;child(0);</span>
<span class="c">        auto shape = x-&gt;shape();</span>
<span class="c">        size_t lastAxis = shape.size() - 1;</span>
<span class="c">        size_t axis;</span>
<span class="c">        E::tryGetAxisAttribute&lt;SumNodeOp&gt;(v, axis) || E::fail();</span>
<span class="c">        if (axis != lastAxis)   // bring axis to be reduced into last dimension so that we can MatMul</span>
<span class="c">          x = swapAxes(x, (int)axis, (int)lastAxis);</span>
<span class="c">        auto ones = newConstant(v, {x-&gt;shape().back(), 1}, 1.0f, &quot;ones&quot;);</span>
<span class="c">        n = dot(x, ones);       // [..., D] * [D, 1] = [..., 1]</span>
<span class="c">        if (axis != lastAxis)   // and swap it back</span>
<span class="c">          n = swapAxes(n, (int)axis, (int)lastAxis);</span>
<span class="c">        //LOG(info, &quot;OVERWRITING sum {}/{}, {} -&gt; {} -&gt; . -&gt; {}&quot;, axis, lastAxis, std::string(shape), std::string(x-&gt;shape()), std::string(n-&gt;shape()));</span>
<span class="c">      }</span>
<span class="c">      else if (v-&gt;type() == &quot;layer_normalization&quot;) {</span>
<span class="c">        // layerNorm along last axis</span>
<span class="c">        auto x = v-&gt;child(0);</span>
<span class="c">        auto s = v-&gt;child(1);</span>
<span class="c">        auto b = v-&gt;child(2);</span>
<span class="c">        auto vecDim = x-&gt;shape().back();</span>
<span class="c">        // for summing up elements, we use MatMul</span>
<span class="c">        auto onesOverDim = newConstant(v, {vecDim, 1}, 1.0f / vecDim, &quot;ones_over_dim&quot;);</span>
<span class="c">        // compute mean and variance</span>
<span class="c">        auto mean = dot(x, onesOverDim);</span>
<span class="c">        auto x0 = x - mean;</span>
<span class="c">        auto var = dot(x0 * x0, onesOverDim);</span>
<span class="c">        // variance-normalize</span>
<span class="c">        float epsilon;</span>
<span class="c">        E::tryGetEpsilonAttribute&lt;LayerNormalizationOp&gt;(v, epsilon) || E::fail();</span>
<span class="c">        auto sigma = sqrt(newConstant(v, {}, epsilon, &quot;epsilon&quot;) + var);</span>
<span class="c">        auto xnorm = x0 / sigma;</span>
<span class="c">        // and final scale/bias</span>
<span class="c">        n = xnorm * s + b;</span>
<span class="c">        //LOG(info, &quot;OVERWRITING layerNorm {} -&gt; {}&quot;, std::string(x-&gt;shape()), std::string(mean-&gt;shape()));</span>
<span class="c">      }</span>
<span class="c">      else</span>
<span class="cp">#endif</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;scalar_add&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">scalar</span><span class="p">{};</span>
        <span class="n">E</span><span class="o">::</span><span class="n">tryGetScalarAttribute</span><span class="o">&lt;</span><span class="n">ScalarAddNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span> <span class="o">||</span> <span class="n">E</span><span class="o">::</span><span class="n">fail</span><span class="p">();</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">newConstant</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{},</span> <span class="n">scalar</span><span class="p">,</span> <span class="s">&quot;scalar&quot;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;scalar_mult&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">scalar</span><span class="p">{};</span>
        <span class="n">E</span><span class="o">::</span><span class="n">tryGetScalarAttribute</span><span class="o">&lt;</span><span class="n">ScalarMultNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span> <span class="o">||</span> <span class="n">E</span><span class="o">::</span><span class="n">fail</span><span class="p">();</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">newConstant</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{},</span> <span class="n">scalar</span><span class="p">,</span> <span class="s">&quot;scalar&quot;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;square&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
      <span class="p">}</span>
<span class="cp">#if 0</span><span class="c">  // @BUGBUG: not supported for now, since we don&#39;t aim at training. This requires a function called select() which no longer exists.</span>
<span class="c">      else if (v-&gt;type() == &quot;x-ent&quot;) {</span>
<span class="c">        auto x = v-&gt;child(0); // logits : some_shape + (num_classes,)</span>
<span class="c">        auto y = v-&gt;child(1); // indices: some_shape + (1,)</span>
<span class="c">        // C = sum_{v in V}(-logsoftmax(A) * delta(v, i) = -logsoftmax(A)[i]</span>
<span class="c">        auto xShape = x-&gt;shape();</span>
<span class="c">        // note: indices are flattened into a vector</span>
<span class="c">        auto yShape = xShape;   // true shape of y -&gt; result shape</span>
<span class="c">        yShape.back() = 1;</span>
<span class="c">        auto nl = logsoftmax(x);</span>
<span class="c">        //nl-&gt;debug(&quot;nl&quot;);</span>
<span class="cp">#if 1   // ONNX has no batched select/gather, so we must fake it.</span>
<span class="c">        // We first flatten the batch to a vector.</span>
<span class="c">        nl = flatten(nl); // now x: (totalWords, vocabSize), while  y: (totalWords,)</span>
<span class="c">        // Then we create a constant with offsets into this vector</span>
<span class="c">        auto vocabSize = xShape.back();</span>
<span class="c">        auto totalWords = xShape.elements() / vocabSize; // total batch size across batch and length dimension</span>
<span class="c">        std::vector&lt;unsigned int&gt; offs;</span>
<span class="c">        for (size_t i = 0; i &lt; totalWords; i++)</span>
<span class="c">          offs.push_back((unsigned int)(i * vocabSize));</span>
<span class="c">        auto offsExpr = v-&gt;graph()-&gt;indices(offs);</span>
<span class="c">        offsExpr-&gt;set_name(&quot;const_&quot; + v-&gt;type() + &quot;_offsets_&quot; + std::to_string(v-&gt;getId()));</span>
<span class="c">        // Now form indices into the flattened vector using the offsets</span>
<span class="c">        y = y + offsExpr; // -&gt; [y0, y1 + V, y2 + 2V, ...]</span>
<span class="c">        // Now we can select with this.</span>
<span class="c">        n = -select(nl, y, /*axis=*/-1);</span>
<span class="c">        n = reshape(n, yShape);</span>
<span class="c">        //LOG(info, &quot;x-ent: {}, {} -&gt; {}&quot;, std::string(x-&gt;shape()), std::string(y-&gt;shape()), std::string(n-&gt;shape()));</span>
<span class="cp">#else   // better version, but unfortunately neither Marian nor ONNX support batched select/gather</span>
<span class="c">        y = reshape(y, yShape);</span>
<span class="c">        n = -select(nl, y, /*axis=*/-1); // @TODO: update if we ever add axis_ to x-ent</span>
<span class="cp">#endif</span>
      <span class="p">}</span>
<span class="cp">#endif</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;highway&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">oneExpr</span> <span class="o">=</span> <span class="n">newConstant</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{},</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="s">&quot;one&quot;</span><span class="p">);</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">oneExpr</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;bdot&quot;</span> <span class="o">||</span>
               <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;dot&quot;</span>  <span class="cm">/*  &amp;&amp; (v-&gt;child(0)-&gt;shape().size() != 2 || v-&gt;child(1)-&gt;shape().size() != 2)*/</span><span class="p">)</span> <span class="o">||</span>
               <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;affine&quot;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)))</span> <span class="p">{</span>
        <span class="c1">// ONNX MatMul behaves like Numpy matmul, and therefore implements batched semantics.</span>
        <span class="c1">// ONNX MatMul has no transA/B/scale parameters, so we must handle those as explicit operations.</span>
        <span class="c1">// affine() could also be ONNX Gemm, but that does not support outer ranks, so we just expand it into dot().</span>
        <span class="c1">// @TODO: ^^ we can just reshape(). Code is already below, but ONNX Gemm always crashes, so this is disabled for now.</span>
        <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="n">transA</span><span class="p">{},</span> <span class="n">transB</span><span class="p">{};</span> <span class="kt">float</span> <span class="n">scalar</span><span class="p">{};</span> <span class="c1">// (gcc complains without the initializers, which I think is a compiler bug)</span>
        <span class="n">E</span><span class="o">::</span><span class="n">tryGetMatMulAttributes</span><span class="o">&lt;</span><span class="n">DotNodeOp</span><span class="o">&gt;</span>       <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span> <span class="o">||</span>
        <span class="n">E</span><span class="o">::</span><span class="n">tryGetMatMulAttributes</span><span class="o">&lt;</span><span class="n">DotBatchedNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span> <span class="o">||</span>
        <span class="n">E</span><span class="o">::</span><span class="n">tryGetMatMulAttributes</span><span class="o">&lt;</span><span class="n">AffineNodeOp</span><span class="o">&gt;</span>    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span> <span class="o">||</span> <span class="n">E</span><span class="o">::</span><span class="n">fail</span><span class="p">();</span>
        <span class="c1">//LOG(info, &quot;{} {}={}x{} trans = {}, {} and scalar = {}&quot;,</span>
        <span class="c1">//          v-&gt;type(), std::string(v-&gt;shape()), std::string(a-&gt;shape()), std::string(b-&gt;shape()), transA, transB, scalar);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">transA</span> <span class="o">||</span> <span class="n">transB</span> <span class="o">||</span> <span class="n">scalar</span> <span class="o">!=</span> <span class="mf">1.0f</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;affine&quot;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)))</span> <span class="p">{</span>
          <span class="c1">//LOG(info, &quot;patching {} {}={}x{} due to trans = {}, {} and scalar = {}&quot;,</span>
          <span class="c1">//          v-&gt;type(), std::string(v-&gt;shape()), std::string(a-&gt;shape()), std::string(b-&gt;shape()), transA, transB, scalar);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">transA</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// note: we don&#39;t optimize for this since it does not happen in present models</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">swapAxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">-1</span><span class="p">,</span> <span class="mi">-2</span><span class="p">);</span>
            <span class="n">transA</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// @BUGBUG: Gemm always crashes with ONNX runtime. So we can&#39;t do this optimization.</span>
          <span class="c1">//if (v-&gt;type() != &quot;bdot&quot; &amp;&amp; b-&gt;shape().size() == 2) {        // [A,B,C,I,J] x [J,K] --&gt; reshape into regular matrix product</span>
          <span class="c1">//  ABORT_IF(transA, &quot;Transposition not mapped away??&quot;);</span>
          <span class="c1">//  a = reshape(a, Shape({ a-&gt;shape().elements() / a-&gt;shape()[-1], a-&gt;shape()[-1] }));  // now it&#39;s a regular matrix product, can use Gemm</span>
          <span class="c1">//}</span>
          <span class="cm">/*else*/</span> <span class="k">if</span> <span class="p">(</span><span class="n">transB</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// not a regular matrix product: cannot use Gemm, so must transpose manually</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">swapAxes</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">-1</span><span class="p">,</span> <span class="mi">-2</span><span class="p">);</span>
            <span class="n">transB</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="kt">float</span> <span class="n">extraScalar</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;bdot&quot;</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// this maps to ONNX MatMul</span>
            <span class="n">extraScalar</span> <span class="o">=</span> <span class="n">scalar</span><span class="p">;</span>     <span class="c1">// must add extra scale operation at the end</span>
            <span class="n">scalar</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>            <span class="c1">// we cannot scale in ONNX MatMul</span>
            <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">transA</span> <span class="o">||</span> <span class="n">transB</span> <span class="o">||</span> <span class="n">scalar</span> <span class="o">!=</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="s">&quot;Transposition and/or scalar not mapped away??&quot;</span><span class="p">);</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">bdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">scalar</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">else</span> <span class="p">{</span> <span class="c1">// dot, affine</span>
            <span class="c1">// @BUGBUG: Gemm always crashes with ONNX runtime. So we can&#39;t do this optimization.</span>
            <span class="c1">//if (a-&gt;shape().size() != 2 || b-&gt;shape().size() != 2) {  // not ONNX MatMul: must use explicit scale operation</span>
              <span class="n">extraScalar</span> <span class="o">=</span> <span class="n">scalar</span><span class="p">;</span>
              <span class="n">scalar</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
            <span class="c1">//}</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">scalar</span><span class="p">);</span>
            <span class="c1">//LOG(info, &quot;{} {} x {} -&gt; {}&quot;, v-&gt;type(), std::string(a-&gt;shape()), std::string(b-&gt;shape()), std::string(n-&gt;shape()));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;affine&quot;</span><span class="p">)</span>
              <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="c1">//if (v-&gt;type() == &quot;affine&quot;)</span>
          <span class="c1">//  LOG(info, &quot;{} + {} -&gt; {}&quot;, v-&gt;type(), std::string(v-&gt;child(2)-&gt;shape()), std::string(n-&gt;shape()));</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">extraScalar</span> <span class="o">!=</span> <span class="mf">1.0f</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">newConstant</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{},</span> <span class="n">extraScalar</span><span class="p">,</span> <span class="s">&quot;scalar&quot;</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()</span> <span class="o">!=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">())</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">());</span>  <span class="c1">// if we did some shaping to get a regular matrix product, reshape it back</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;affine&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// affine() may have a redundant vector of ones, which we strip here</span>
        <span class="c1">// This then becomes Gemm.</span>
        <span class="n">v</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">().</span><span class="n">resize</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;affine() can presently not stripped of its additional ones vector. Need to fix Marian first to run with this.&quot;</span><span class="p">);</span>
        <span class="c1">// Note: Cannot recreate affine() as a new node, because that will get that fourth axis again.</span>
        <span class="c1">// @BUGBUG: This will crash.</span>
      <span class="p">}</span>
<span class="cp">#if 0</span><span class="c"> // @BUGBUG: select() no longer exists. Likely some other ops are missing now.</span>
<span class="c">      else if (v-&gt;type() == &quot;select&quot;) {</span>
<span class="c">        // select maps to Gather, and is limited to non-batched and the last axis</span>
<span class="c">        size_t axis;</span>
<span class="c">        E::tryGetAxisAttribute&lt;SelectNodeOp&gt;(v, axis) || E::fail();</span>
<span class="c">        auto data    = v-&gt;child(0);</span>
<span class="c">        auto indices = v-&gt;child(1);</span>
<span class="c">        auto dataShape = data-&gt;shape();</span>
<span class="c">        auto dataRank = dataShape.size();</span>
<span class="c">        auto indicesShape = indices-&gt;shape();</span>
<span class="c">        auto indicesRank = indicesShape.size();</span>
<span class="c">        auto indicesDim = indicesShape[(int)axis - (int)dataShape.size()];</span>
<span class="c">        ABORT_IF(indicesShape.elements() != indicesDim, &quot;ONNX does not support batched select()&quot;);</span>
<span class="c">        if (indicesRank != 1 || axis != dataRank - 1) {</span>
<span class="c">          if (indicesRank != 1)</span>
<span class="c">            indices = flatten(indices); // (batched Gather is not supported)</span>
<span class="c">          if (axis != dataRank - 1)</span>
<span class="c">            data = swapAxes(data, (int)axis, (int)dataRank - 1); // swap select axis to back</span>
<span class="c">          n = select(data, indices, -1);</span>
<span class="c">          if (axis != dataRank - 1)</span>
<span class="c">            n = swapAxes(n, (int)axis, (int)dataRank - 1);</span>
<span class="c">        }</span>
<span class="c">      }</span>
<span class="cp">#endif</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;layer_normalization&quot;</span> <span class="o">&amp;&amp;</span>
               <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
        <span class="c1">// ONNX InferenceNormalization is layer norm for shapes (N, C, D, ...) where N and C are</span>
        <span class="c1">// batch dimensions, and D... all share normalization statistics (&quot;mean and variance are</span>
        <span class="c1">// computed per instance per channel&quot;).</span>
        <span class="c1">// Marian layer_normalization normalizes along axis -1.</span>
        <span class="c1">// Hence, if the input rank is != 3, we must temporarily reshape.</span>
        <span class="c1">// Also, ONNX expects scale and bias to contain C values (one for each c), while Marian</span>
        <span class="c1">// shares scale and bias along C but uses vectors of dim D. Hence, we must apply them manually.</span>
        <span class="c1">// This op gets replaced by a sequence that includes the same op, but with</span>
        <span class="c1">// gamma and beta being scalars, which is invalid for Marian.</span>
        <span class="c1">// (This will fail if layerNorm is applied to a scalar, which makes no sense.)</span>
        <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">:</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// beta is optional</span>
        <span class="k">auto</span> <span class="n">outShape</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">vecDim</span> <span class="o">=</span> <span class="n">outShape</span><span class="p">[</span><span class="mi">-1</span><span class="p">];</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">outShape</span><span class="p">.</span><span class="n">elements</span><span class="p">()</span> <span class="o">/</span> <span class="n">vecDim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vecDim</span><span class="p">});</span> <span class="c1">// -&gt; (N, C, D)</span>
        <span class="n">ABORT_IF</span><span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">())</span> <span class="o">||</span>
                 <span class="p">(</span><span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()),</span>
                 <span class="s">&quot;scale and bias must be vectors or single rows&quot;</span><span class="p">);</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span>
          <span class="n">b</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="c1">//LOG(info, &quot;layer_normalization reshaped from {} to {}&quot;, std::string(outShape), std::string(x-&gt;shape()));</span>
        <span class="kt">float</span> <span class="n">epsilon</span><span class="p">;</span>
        <span class="n">E</span><span class="o">::</span><span class="n">tryGetEpsilonAttribute</span><span class="o">&lt;</span><span class="n">LayerNormalizationOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span> <span class="o">||</span> <span class="n">E</span><span class="o">::</span><span class="n">fail</span><span class="p">();</span>
        <span class="c1">//LOG(info, &quot;LNORM {}, {}, {} vs. {}, {}&quot;, std::string(x-&gt;shape()), std::string(oneExpr-&gt;shape()), std::string(zeroExpr-&gt;shape()), std::string(s-&gt;shape()), std::string(b-&gt;shape()));</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">layerNorm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">newConstant</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="s">&quot;one&quot;</span><span class="p">),</span> <span class="n">newConstant</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="s">&quot;zero&quot;</span><span class="p">),</span> <span class="n">epsilon</span><span class="p">);</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span>
          <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">outShape</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;const&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;dropout_mask_&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// This is a randomly generated mask. We must replace this by RandomUniform.</span>
        <span class="c1">// This is done in 3 steps:</span>
        <span class="c1">//  - We expand v as (uniform &lt; keepProb) * scale; but because Marian has no &quot;&lt;&quot;, we use &quot;-&quot; instead for now. @HACKHACK 1</span>
        <span class="c1">//  - The uniform for now is a constant, which later gets converted as ONNX RandomUniform(0,1).  @HACKHACK 2</span>
        <span class="c1">//  - The &quot;-&quot; with left arg of v gets patched to become ONNX Less. @HACKHACK 1 fix-up</span>
        <span class="k">auto</span> <span class="n">pString</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">();</span>
        <span class="n">pString</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pString</span><span class="p">.</span><span class="n">find_last_of</span><span class="p">(</span><span class="sc">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">dropProb</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stof</span><span class="p">(</span><span class="n">pString</span><span class="p">);</span>
        <span class="c1">//LOG(info, &quot;Found dropProb constant {} -&gt; {}&quot;, v-&gt;name(), dropProb);</span>
        <span class="kt">float</span> <span class="n">keepProb</span> <span class="o">=</span> <span class="mf">1.f</span> <span class="o">-</span> <span class="n">dropProb</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.f</span> <span class="o">/</span> <span class="n">keepProb</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">uniformExpr</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">constant</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span> <span class="n">inits</span><span class="o">::</span><span class="n">zeros</span><span class="p">());</span>
        <span class="n">uniformExpr</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="s">&quot;opRandomUniform_&quot;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">()));</span> <span class="c1">// not using newConstant because of special node name</span>
        <span class="c1">// (uniform(0,1) &lt; keepProb) * scale</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">uniformExpr</span> <span class="o">-</span> <span class="n">newConstant</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{},</span> <span class="n">keepProb</span><span class="p">,</span> <span class="s">&quot;keepProb&quot;</span><span class="p">))</span> <span class="o">*</span> <span class="n">newConstant</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{},</span> <span class="n">scale</span><span class="p">,</span> <span class="s">&quot;scale&quot;</span><span class="p">);</span>
        <span class="c1">// @HACKHACK 1: Marian has no &quot;less than&quot;, so we use &quot;-&quot; instead. Must patch that back later.</span>
        <span class="c1">// @HACKHACK 2: We use a specially-named constant as the placeholder for uniform(0,1).</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// copy key properties</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">!=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">())</span> <span class="c1">// (this tests for the empty name)</span>
          <span class="n">n</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;_expanded&quot;</span><span class="p">);</span> <span class="c1">// (this branch is actually never taken presently)</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">setTrainable</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">trainable</span><span class="p">());</span>
        <span class="c1">// register mapping</span>
        <span class="n">nodeReferenceRedirector</span><span class="p">.</span><span class="n">addRedirect</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;[graph] Macro op {} expanded with new root op {}&quot;</span><span class="p">,</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">(),</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">functionDef</span> <span class="p">:</span> <span class="n">functionDefs</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">output</span> <span class="p">:</span> <span class="n">functionDef</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">second</span><span class="p">)</span>  <span class="c1">// redirect outputs: a root may also have been a macro op</span>
        <span class="n">nodeReferenceRedirector</span><span class="p">.</span><span class="n">redirectReference</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">output</span> <span class="p">:</span> <span class="n">functionDef</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>   <span class="c1">// redirect inputs: inputs may be the outputs of other functions</span>
        <span class="n">nodeReferenceRedirector</span><span class="p">.</span><span class="n">redirectReference</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Since we added the expanded ops to the end of nodesForward_, we must bring it</span>
    <span class="c1">// back into topologically sorted order.</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;[graph] After creating expanded nodes, we now have {} nodes&quot;</span><span class="p">,</span> <span class="n">nodesForward_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">using</span> <span class="k">namespace</span> <span class="n">onnx</span><span class="p">;</span> <span class="c1">// all -Proto classes come from here</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">LENGTH_AXIS_NAME</span> <span class="o">=</span> <span class="s">&quot;SOURCE_LENGTH&quot;</span><span class="p">;</span>  <span class="c1">// the source length is a named (dynamic) axis with this name</span>

  <span class="c1">// C++ port of a subset of https://github.com/onnx/onnx/blob/master/onnx/helper.py</span>
  <span class="k">static</span> <span class="n">ValueInfoProto</span> <span class="n">makeValueInfoProto</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">TensorProto_DataType</span> <span class="n">dataType</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">shape</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sentinelDim</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ValueInfoProto</span> <span class="n">valueInfo</span><span class="p">;</span>
    <span class="n">valueInfo</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">auto</span><span class="o">*</span> <span class="n">valueInfoType</span> <span class="o">=</span> <span class="n">valueInfo</span><span class="p">.</span><span class="n">mutable_type</span><span class="p">();</span>
    <span class="k">auto</span><span class="o">*</span> <span class="n">valueInfoTensorType</span> <span class="o">=</span> <span class="n">valueInfoType</span><span class="o">-&gt;</span><span class="n">mutable_tensor_type</span><span class="p">();</span>
    <span class="n">valueInfoTensorType</span><span class="o">-&gt;</span><span class="n">set_elem_type</span><span class="p">(</span><span class="n">dataType</span><span class="p">);</span>
    <span class="k">auto</span><span class="o">*</span> <span class="n">valueInfoTensorTypeShape</span> <span class="o">=</span> <span class="n">valueInfoTensorType</span><span class="o">-&gt;</span><span class="n">mutable_shape</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">dim</span> <span class="p">:</span> <span class="n">shape</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dim</span> <span class="o">==</span> <span class="n">sentinelDim</span><span class="p">)</span>
        <span class="n">valueInfoTensorTypeShape</span><span class="o">-&gt;</span><span class="n">add_dim</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_dim_param</span><span class="p">(</span><span class="n">LENGTH_AXIS_NAME</span><span class="p">);</span>
      <span class="k">else</span>
        <span class="n">valueInfoTensorTypeShape</span><span class="o">-&gt;</span><span class="n">add_dim</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_dim_value</span><span class="p">(</span><span class="n">dim</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">valueInfo</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="c1">// note: for now, must pass the matching dataType (not checked)</span>
  <span class="k">static</span> <span class="n">TensorProto</span> <span class="n">makeTensorProto</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">TensorProto_DataType</span> <span class="n">dataType</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">shape</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vals</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TensorProto</span> <span class="n">tensor</span><span class="p">;</span>
    <span class="n">tensor</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">tensor</span><span class="p">.</span><span class="n">set_data_type</span><span class="p">(</span><span class="n">dataType</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">dim</span> <span class="p">:</span> <span class="n">shape</span><span class="p">)</span>
      <span class="n">tensor</span><span class="p">.</span><span class="n">add_dims</span><span class="p">(</span><span class="n">dim</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c">   // @HACKHACK for debugging: keep files small during debugging, so that we can load and view those files easily</span>
<span class="c">    *tensor.mutable_raw_data() = std::string((char*)vals.data(), (char*)(vals.data() + std::min(size_t(10), vals.size())));</span>
<span class="cp">#else</span>
    <span class="o">*</span><span class="n">tensor</span><span class="p">.</span><span class="n">mutable_raw_data</span><span class="p">()</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">vals</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">vals</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">vals</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="cp">#endif</span>
    <span class="k">return</span> <span class="n">tensor</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">addAttribute</span><span class="p">(</span><span class="n">NodeProto</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AttributeProto</span><span class="o">*</span> <span class="n">attribute</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">add_attribute</span><span class="p">();</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_type</span><span class="p">(</span><span class="n">AttributeProto_AttributeType</span><span class="o">::</span><span class="n">AttributeProto_AttributeType_INTS</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">val</span><span class="p">)</span>
      <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">add_ints</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">addAttribute</span><span class="p">(</span><span class="n">NodeProto</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AttributeProto</span><span class="o">*</span> <span class="n">attribute</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">add_attribute</span><span class="p">();</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_type</span><span class="p">(</span><span class="n">AttributeProto_AttributeType</span><span class="o">::</span><span class="n">AttributeProto_AttributeType_INTS</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">val</span><span class="p">)</span>
      <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">add_ints</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">addAttribute</span><span class="p">(</span><span class="n">NodeProto</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AttributeProto</span><span class="o">*</span> <span class="n">attribute</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">add_attribute</span><span class="p">();</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_type</span><span class="p">(</span><span class="n">AttributeProto_AttributeType</span><span class="o">::</span><span class="n">AttributeProto_AttributeType_STRING</span><span class="p">);</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_s</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">addAttribute</span><span class="p">(</span><span class="n">NodeProto</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">float</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AttributeProto</span><span class="o">*</span> <span class="n">attribute</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">add_attribute</span><span class="p">();</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_type</span><span class="p">(</span><span class="n">AttributeProto_AttributeType</span><span class="o">::</span><span class="n">AttributeProto_AttributeType_FLOAT</span><span class="p">);</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_f</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">addAttribute</span><span class="p">(</span><span class="n">NodeProto</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">AttributeProto</span><span class="o">*</span> <span class="n">attribute</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">add_attribute</span><span class="p">();</span>
      <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
      <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_type</span><span class="p">(</span><span class="n">AttributeProto_AttributeType</span><span class="o">::</span><span class="n">AttributeProto_AttributeType_INT</span><span class="p">);</span>
      <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_i</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">addAttribute</span><span class="p">(</span><span class="n">NodeProto</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">AttributeProto</span><span class="o">*</span> <span class="n">attribute</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">add_attribute</span><span class="p">();</span>
      <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
      <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_type</span><span class="p">(</span><span class="n">AttributeProto_AttributeType</span><span class="o">::</span><span class="n">AttributeProto_AttributeType_INT</span><span class="p">);</span>
      <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_i</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">addAttribute</span><span class="p">(</span><span class="n">NodeProto</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AttributeProto</span><span class="o">*</span> <span class="n">attribute</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">add_attribute</span><span class="p">();</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_type</span><span class="p">(</span><span class="n">AttributeProto_AttributeType</span><span class="o">::</span><span class="n">AttributeProto_AttributeType_INT</span><span class="p">);</span>
    <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">set_i</span><span class="p">(</span><span class="n">val</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// bool is stored as int in ONNX</span>
  <span class="p">}</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">addAttributes</span><span class="p">(</span><span class="n">NodeProto</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// end of recursion</span>
  <span class="p">}</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Attributes</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">addAttributes</span><span class="p">(</span><span class="n">NodeProto</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="n">Attributes</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">moreAttributes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="n">addAttributes</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Attributes</span><span class="o">&gt;</span><span class="p">(</span><span class="n">moreAttributes</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Attributes</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="n">NodeProto</span> <span class="n">makeNode</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">opType</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nodeName</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">outputs</span><span class="p">,</span>
      <span class="n">Attributes</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">attributes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NodeProto</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">node</span><span class="p">.</span><span class="n">mutable_op_type</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">assign</span><span class="p">(</span><span class="n">opType</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">input</span> <span class="p">:</span> <span class="n">inputs</span><span class="p">)</span>
      <span class="n">node</span><span class="p">.</span><span class="n">add_input</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">output</span> <span class="p">:</span> <span class="n">outputs</span><span class="p">)</span>
      <span class="n">node</span><span class="p">.</span><span class="n">add_output</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodeName</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
      <span class="n">node</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">nodeName</span><span class="p">);</span>
    <span class="n">addAttributes</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Attributes</span><span class="o">&gt;</span><span class="p">(</span><span class="n">attributes</span><span class="p">)...);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">GraphProto</span> <span class="n">makeGraph</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NodeProto</span><span class="o">&gt;&amp;</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ValueInfoProto</span><span class="o">&gt;&amp;</span> <span class="n">inputs</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ValueInfoProto</span><span class="o">&gt;&amp;</span> <span class="n">outputs</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TensorProto</span><span class="o">&gt;&amp;</span> <span class="n">initializers</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ValueInfoProto</span><span class="o">&gt;&amp;</span> <span class="n">valueInfos</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GraphProto</span> <span class="n">graph</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">node</span> <span class="p">:</span> <span class="n">nodes</span><span class="p">)</span>
      <span class="o">*</span><span class="n">graph</span><span class="p">.</span><span class="n">add_node</span><span class="p">()</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">graph</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">input</span> <span class="p">:</span> <span class="n">inputs</span><span class="p">)</span>
      <span class="o">*</span><span class="n">graph</span><span class="p">.</span><span class="n">add_input</span><span class="p">()</span> <span class="o">=</span> <span class="n">input</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">output</span> <span class="p">:</span> <span class="n">outputs</span><span class="p">)</span>
      <span class="o">*</span><span class="n">graph</span><span class="p">.</span><span class="n">add_output</span><span class="p">()</span> <span class="o">=</span> <span class="n">output</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">initializer</span><span class="p">:</span> <span class="n">initializers</span><span class="p">)</span>
      <span class="o">*</span><span class="n">graph</span><span class="p">.</span><span class="n">add_initializer</span><span class="p">()</span> <span class="o">=</span> <span class="n">initializer</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">valueInfo</span> <span class="p">:</span> <span class="n">valueInfos</span><span class="p">)</span>
<span class="cp">#if 0</span><span class="c"> // add some as explicit outputs for debugging</span>
<span class="c">      if (valueInfo.name() == &quot;opReshape_292&quot; || valueInfo.name() == &quot;opPad_294&quot;)</span>
<span class="c">        *graph.add_output() = valueInfo;</span>
<span class="c">      else</span>
<span class="cp">#endif</span>
      <span class="o">*</span><span class="n">graph</span><span class="p">.</span><span class="n">add_value_info</span><span class="p">()</span> <span class="o">=</span> <span class="n">valueInfo</span><span class="p">;</span>
    <span class="n">valueInfos</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">graph</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">ModelProto</span> <span class="n">makeModel</span><span class="p">(</span><span class="k">const</span> <span class="n">GraphProto</span><span class="o">&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">producerName</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ModelProto</span> <span class="n">model</span><span class="p">;</span>
    <span class="n">model</span><span class="p">.</span><span class="n">set_ir_version</span><span class="p">(</span><span class="n">IR_VERSION</span><span class="p">);</span>
    <span class="n">model</span><span class="p">.</span><span class="n">set_producer_name</span><span class="p">(</span><span class="n">producerName</span><span class="p">);</span>
    <span class="n">model</span><span class="p">.</span><span class="n">mutable_graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span>
<span class="cp">#define OPSET_IMPORT_VERSION 11</span>
    <span class="n">model</span><span class="p">.</span><span class="n">add_opset_import</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_version</span><span class="p">(</span><span class="n">OPSET_IMPORT_VERSION</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">model</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mapExprOp</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">opMap</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">{</span><span class="s">&quot;+&quot;</span>                      <span class="p">,</span> <span class="s">&quot;Add&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;-&quot;</span>                      <span class="p">,</span> <span class="s">&quot;Sub&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;*&quot;</span>                      <span class="p">,</span> <span class="s">&quot;Mul&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;/&quot;</span>                      <span class="p">,</span> <span class="s">&quot;Div&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;negate&quot;</span>                 <span class="p">,</span> <span class="s">&quot;Neg&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;ReLU&quot;</span>                   <span class="p">,</span> <span class="s">&quot;Relu&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;reshape&quot;</span>                <span class="p">,</span> <span class="s">&quot;Reshape&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;affine&quot;</span>                 <span class="p">,</span> <span class="s">&quot;Gemm&quot;</span><span class="p">},</span>    <span class="c1">// @TODO: is this just a hack, or meant to be used for this? It is not really standard GEMM semantics.</span>
      <span class="p">{</span><span class="s">&quot;bdot&quot;</span>                   <span class="p">,</span> <span class="s">&quot;MatMul&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;dot&quot;</span>                    <span class="p">,</span> <span class="s">&quot;MatMul&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;sigmoid&quot;</span>                <span class="p">,</span> <span class="s">&quot;Sigmoid&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;sqrt&quot;</span>                   <span class="p">,</span> <span class="s">&quot;Sqrt&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;sin&quot;</span>                    <span class="p">,</span> <span class="s">&quot;Sin&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;cos&quot;</span>                    <span class="p">,</span> <span class="s">&quot;Cos&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;tan&quot;</span>                    <span class="p">,</span> <span class="s">&quot;Tan&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;layer_normalization&quot;</span>    <span class="p">,</span> <span class="s">&quot;InstanceNormalization&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;softmax&quot;</span>                <span class="p">,</span> <span class="s">&quot;Softmax&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;logsoftmax&quot;</span>             <span class="p">,</span> <span class="s">&quot;LogSoftmax&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;sum&quot;</span>                    <span class="p">,</span> <span class="s">&quot;ReduceSum&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;transpose&quot;</span>              <span class="p">,</span> <span class="s">&quot;Transpose&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;concat&quot;</span>                 <span class="p">,</span> <span class="s">&quot;Concat&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;sliceView&quot;</span>              <span class="p">,</span> <span class="s">&quot;Slice&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;shift&quot;</span>                  <span class="p">,</span> <span class="s">&quot;Pad&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;rows&quot;</span>                   <span class="p">,</span> <span class="s">&quot;Gather&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;select&quot;</span>                 <span class="p">,</span> <span class="s">&quot;Gather&quot;</span><span class="p">},</span>
      <span class="c1">// The following are never emitted to ONNX. Keep our original type names to avoid special-casing lots of code.</span>
      <span class="p">{</span><span class="s">&quot;const&quot;</span>                  <span class="p">,</span> <span class="s">&quot;const&quot;</span><span class="p">},</span>
      <span class="p">{</span><span class="s">&quot;param&quot;</span>                  <span class="p">,</span> <span class="s">&quot;param&quot;</span><span class="p">}</span>
    <span class="p">};</span>
    <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">opMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span>
    <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">opMap</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">&quot;ONNX export of operation {} is presently not supported&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// get a unique name for an Expr. Either an actual name, or OP_ID if not named.</span>
  <span class="c1">// &#39;nameOverrides&#39; overrides that name. This is used for inputs and outputs.</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getExprName</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Expr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">nameOverrides</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nameOverrides</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nameOverrides</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
      <span class="k">return</span> <span class="n">nameOverrides</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;none&quot;</span><span class="p">)</span> <span class="c1">// Marian assigns &quot;none&quot; to denote an unassigned name</span>
      <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;const&quot;</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;op&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">mapExprOp</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">());</span>
    <span class="c1">// For &#39;const&#39;, do not prefix &quot;op&quot;, so that all internal constants in the system</span>
    <span class="c1">// (i.e. not input data) have a prefix &quot;const_&quot; to distinguish them from weight tensors.</span>
    <span class="k">return</span> <span class="n">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// convert Marian shape into vector&lt;size_t&gt;</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">getExprShape</span><span class="p">(</span><span class="n">Expr</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">shape</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">shape</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="c1">// get TensorProto_DataType for an Expr</span>
  <span class="c1">// Note: We map Marian uint32_t to ONNX signed integers because those are only used</span>
  <span class="c1">// for indices for Gather operations, where Marian requires unsigned and ONNX signed.</span>
  <span class="k">static</span> <span class="n">TensorProto_DataType</span> <span class="n">getExprDataType</span><span class="p">(</span><span class="n">Expr</span> <span class="n">expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">value_type</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">marian</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="nl">float32</span><span class="p">:</span> <span class="k">return</span> <span class="n">TensorProto_DataType</span><span class="o">::</span><span class="n">TensorProto_DataType_FLOAT</span><span class="p">;</span>
      <span class="c1">//case marian::Type::uint32:  //return TensorProto_DataType::TensorProto_DataType_UINT32;</span>
      <span class="k">case</span> <span class="n">marian</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="nl">uint32</span><span class="p">:</span>  <span class="c1">// uint32 becomes ONNX INT32 as well (see above)</span>
      <span class="k">case</span> <span class="n">marian</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="nl">int32</span><span class="p">:</span>   <span class="k">return</span> <span class="n">TensorProto_DataType</span><span class="o">::</span><span class="n">TensorProto_DataType_INT32</span><span class="p">;</span>
      <span class="k">default</span><span class="o">:</span> <span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Tensor type not supported yet&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// convert a Marian constant to an ONNX TensorProto</span>
  <span class="k">static</span> <span class="n">TensorProto</span> <span class="n">makeExprTensorProto</span><span class="p">(</span><span class="n">Expr</span> <span class="n">expr</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Expr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">nameOverrides</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">dataType</span> <span class="o">=</span> <span class="n">getExprDataType</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">name</span>     <span class="o">=</span> <span class="n">getExprName</span>    <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">nameOverrides</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">shape</span>    <span class="o">=</span> <span class="n">getExprShape</span>   <span class="p">(</span><span class="n">expr</span><span class="p">);</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">value_type</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">marian</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="nl">float32</span><span class="p">:</span> <span class="p">{</span> <span class="c1">// @TODO: template this?</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">valBuf</span><span class="p">;</span>
      <span class="n">expr</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">valBuf</span><span class="p">);</span>
      <span class="k">return</span> <span class="nf">makeTensorProto</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dataType</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">valBuf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">marian</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="nl">uint32</span><span class="p">:</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">valBuf</span><span class="p">;</span> <span class="c1">// note: uint32_t still get passed to ONNX as signed INT32 (cf. getExprDataType())</span>
      <span class="n">expr</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">valBuf</span><span class="p">);</span>
      <span class="k">return</span> <span class="nf">makeTensorProto</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dataType</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">valBuf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">marian</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="nl">int32</span><span class="p">:</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">valBuf</span><span class="p">;</span>
      <span class="n">expr</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">valBuf</span><span class="p">);</span>
      <span class="k">return</span> <span class="nf">makeTensorProto</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dataType</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">valBuf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Tensor type not supported yet&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="n">logNode</span><span class="p">(</span><span class="k">const</span> <span class="n">NodeProto</span><span class="o">&amp;</span> <span class="n">node</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&amp;</span> <span class="n">shape</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sentinelDim</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot; = &quot;</span> <span class="o">+</span> <span class="n">node</span><span class="p">.</span><span class="n">op_type</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;(&quot;</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">addComma</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;[&#39;</span><span class="p">)</span> <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;, &quot;</span><span class="p">;</span> <span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">input_size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">inputName</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">input</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">addComma</span><span class="p">();</span>
      <span class="n">s</span> <span class="o">+=</span> <span class="n">inputName</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">attribute_size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">attribute</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">attribute</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">addComma</span><span class="p">();</span>
      <span class="n">s</span> <span class="o">+=</span> <span class="n">attribute</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;=?&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;) : [&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">dim</span> <span class="p">:</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">addComma</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dim</span> <span class="o">==</span> <span class="n">sentinelDim</span><span class="p">)</span>
          <span class="n">s</span> <span class="o">+=</span> <span class="n">LENGTH_AXIS_NAME</span><span class="p">;</span>
      <span class="k">else</span>
          <span class="n">s</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">dim</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39;]&#39;</span><span class="p">);</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// convert a Marian Expr to an ONNX node</span>
  <span class="c1">// This function needs inputs and initializers because the special case of Reshape needs</span>
  <span class="c1">// to create an extra input with initializer.</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">addExprNode</span><span class="p">(</span><span class="n">Expr</span> <span class="n">expr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NodeProto</span><span class="o">&gt;&amp;</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ValueInfoProto</span><span class="o">&gt;&amp;</span> <span class="n">inputs</span><span class="p">,</span>
                          <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TensorProto</span><span class="o">&gt;&amp;</span> <span class="n">initializers</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Expr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">nameOverrides</span><span class="p">,</span> <span class="k">const</span> <span class="n">InputsMap</span><span class="o">&amp;</span> <span class="n">inputsMap</span><span class="p">,</span>
                          <span class="kt">size_t</span> <span class="n">sentinelDim</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// get all children</span>
    <span class="c1">// These may reference inputs, and hence must be mapped right here.</span>
    <span class="c1">// The original child in this case is not on the tape.</span>
    <span class="k">auto</span> <span class="n">children</span> <span class="o">=</span> <span class="n">expr</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">child</span> <span class="p">:</span> <span class="n">children</span><span class="p">)</span>
      <span class="n">child</span> <span class="o">=</span> <span class="n">inputsMap</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

    <span class="c1">// inputs are referenced by their node names (also when they are leaves)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">inputNames</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">child</span> <span class="p">:</span> <span class="n">children</span><span class="p">)</span>
      <span class="n">inputNames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">getExprName</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">nameOverrides</span><span class="p">));</span>

    <span class="k">auto</span> <span class="n">name</span> <span class="o">=</span> <span class="n">getExprName</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">nameOverrides</span><span class="p">);</span> <span class="c1">// node name is used as both output name and node name</span>
    <span class="k">auto</span> <span class="n">op</span> <span class="o">=</span> <span class="n">mapExprOp</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>

    <span class="c1">//if (op == &quot;MatMul&quot; &amp;&amp; expr-&gt;child(0)-&gt;shape().size() == 2 &amp;&amp; expr-&gt;child(1)-&gt;shape().size() == 2) {</span>
    <span class="c1">//  op = &quot;Gemm&quot;;</span>
    <span class="c1">//}</span>

<span class="cp">#if 1 </span><span class="c1">// workaround for onnxruntime which does not handle Pad correctly</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="s">&quot;Pad&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Implement Pad as Slice &gt;&gt; Concat</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shifts</span><span class="p">;</span>
      <span class="kt">float</span> <span class="n">padValue</span><span class="p">{};</span> <span class="c1">// (compiler bug: without initialization, I get an uninit warning, yet it is correctly set)</span>
      <span class="n">E</span><span class="o">::</span><span class="n">tryGetShiftAttributes</span><span class="o">&lt;</span><span class="n">ShiftNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">padValue</span><span class="p">)</span> <span class="o">||</span> <span class="n">E</span><span class="o">::</span><span class="n">fail</span><span class="p">();</span>
      <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;can only shift by one&quot;</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">shifts</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;can only shift along first axis&quot;</span><span class="p">);</span>
      <span class="k">auto</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">getExprShape</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="c1">// Slice [0:-1,:,:]</span>
      <span class="k">auto</span> <span class="n">sliceName</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;_Slice&quot;</span><span class="p">;</span>
      <span class="k">auto</span> <span class="n">sliceNode</span> <span class="o">=</span> <span class="n">makeNode</span><span class="p">(</span><span class="s">&quot;Slice&quot;</span><span class="p">,</span> <span class="n">sliceName</span><span class="p">,</span> <span class="n">inputNames</span><span class="p">,</span> <span class="p">{</span><span class="n">sliceName</span><span class="p">});</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">sliceNode</span><span class="p">,</span> <span class="s">&quot;axes&quot;</span><span class="p">,</span>   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">});</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">sliceNode</span><span class="p">,</span> <span class="s">&quot;starts&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">});</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">sliceNode</span><span class="p">,</span> <span class="s">&quot;ends&quot;</span><span class="p">,</span>   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">});</span> <span class="c1">// drop last step</span>
      <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sliceNode</span><span class="p">);</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;Pad slice op {}&quot;</span><span class="p">,</span> <span class="n">sliceName</span><span class="p">);</span>
      <span class="c1">// create a padding constant</span>
      <span class="k">auto</span> <span class="n">paddingName</span> <span class="o">=</span> <span class="s">&quot;const_&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;_Padding&quot;</span><span class="p">;</span>
      <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">dim</span> <span class="p">:</span> <span class="n">shape</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">*=</span> <span class="n">dim</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
      <span class="n">inputs</span><span class="p">.</span>      <span class="n">push_back</span><span class="p">(</span><span class="n">makeValueInfoProto</span><span class="p">(</span><span class="n">paddingName</span><span class="p">,</span> <span class="n">TensorProto_DataType</span><span class="o">::</span><span class="n">TensorProto_DataType_FLOAT</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">sentinelDim</span><span class="p">));</span>
      <span class="n">initializers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">makeTensorProto</span>   <span class="p">(</span><span class="n">paddingName</span><span class="p">,</span> <span class="n">TensorProto_DataType</span><span class="o">::</span><span class="n">TensorProto_DataType_FLOAT</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">zeros</span><span class="p">));</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;Pad constant {}&quot;</span><span class="p">,</span> <span class="n">paddingName</span><span class="p">);</span>
      <span class="c1">// Concat([paddingNode, sliceNode], axis=0)</span>
      <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">makeNode</span><span class="p">(</span><span class="s">&quot;Concat&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">{</span><span class="n">paddingName</span><span class="p">,</span> <span class="n">sliceName</span><span class="p">},</span> <span class="p">{</span><span class="n">name</span><span class="p">});</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;axis&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;Pad concat op {}&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif</span>

    <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">makeNode</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">inputNames</span><span class="p">,</span> <span class="p">{</span><span class="n">name</span><span class="p">});</span>
    <span class="c1">//LOG(info, &quot;NODE {} {} -&gt; {}&quot;, name, expr-&gt;type(), E::mapExprOp(expr));</span>

    <span class="c1">// add attributes needed by some operators</span>

    <span class="c1">// fix up inputs</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">op_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;Reshape&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Reshape requires the shape itself to be a tensor.</span>
      <span class="k">auto</span> <span class="n">shapeInputName</span> <span class="o">=</span> <span class="s">&quot;const_&quot;</span> <span class="o">+</span> <span class="n">getExprName</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">{})</span> <span class="o">+</span> <span class="s">&quot;_shape_attr&quot;</span><span class="p">;</span>
      <span class="o">*</span><span class="n">node</span><span class="p">.</span><span class="n">add_input</span><span class="p">()</span> <span class="o">=</span> <span class="n">shapeInputName</span><span class="p">;</span>
      <span class="c1">// create a new input and a new initializer</span>
      <span class="k">auto</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">getExprShape</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
      <span class="k">auto</span> <span class="n">shape64</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">shape</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">shape</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">dim</span> <span class="p">:</span> <span class="n">shape64</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dim</span> <span class="o">==</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">sentinelDim</span><span class="p">)</span>
          <span class="n">dim</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>  <span class="c1">// means that this one is inferred at runtime</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">shapeShape</span><span class="p">{</span><span class="n">shape</span><span class="p">.</span><span class="n">size</span><span class="p">()};</span> <span class="c1">// ONNX Reshape requires shape in INT64</span>
      <span class="n">inputs</span><span class="p">.</span>      <span class="n">push_back</span><span class="p">(</span><span class="n">makeValueInfoProto</span><span class="p">(</span><span class="n">shapeInputName</span><span class="p">,</span> <span class="n">TensorProto_DataType</span><span class="o">::</span><span class="n">TensorProto_DataType_INT64</span><span class="p">,</span> <span class="n">shapeShape</span><span class="p">,</span> <span class="n">sentinelDim</span><span class="p">));</span>
      <span class="n">initializers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">makeTensorProto</span>   <span class="p">(</span><span class="n">shapeInputName</span><span class="p">,</span> <span class="n">TensorProto_DataType</span><span class="o">::</span><span class="n">TensorProto_DataType_INT64</span><span class="p">,</span> <span class="n">shapeShape</span><span class="p">,</span> <span class="n">shape64</span><span class="p">));</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">shapeInputName</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">dim</span> <span class="p">:</span> <span class="n">shape64</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">dim</span><span class="p">);</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// axis attribute</span>
    <span class="kt">size_t</span> <span class="n">axis</span><span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">axes</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="o">::</span><span class="n">tryGetAxisAttribute</span><span class="o">&lt;</span><span class="n">ConcatenateNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="c1">// ||</span>
        <span class="c1">//E::tryGetAxisAttribute&lt;SelectNodeOp&gt;(expr, axis)</span>
        <span class="p">)</span> <span class="p">{</span> <span class="c1">// axis_ -&gt; &#39;axis&#39;</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;axis&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="o">::</span><span class="n">tryGetAxisAttribute</span><span class="o">&lt;</span><span class="n">ReduceNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">||</span>
             <span class="n">E</span><span class="o">::</span><span class="n">tryGetAxisAttribute</span><span class="o">&lt;</span><span class="n">SliceViewNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// {axis_} -&gt; &#39;axes&#39;</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;axes&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{</span><span class="n">axis</span><span class="p">});</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="o">::</span><span class="n">tryGetAxesAttribute</span><span class="o">&lt;</span><span class="n">TransposeNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">axes</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// here, the axes are called &#39;perm&#39;</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;perm&quot;</span><span class="p">,</span> <span class="n">axes</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">op_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;Softmax&quot;</span> <span class="o">||</span> <span class="n">node</span><span class="p">.</span><span class="n">op_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;LogSoftmax&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Note: ONNX (Log)Softmax is not along an axis; rather along all axes &gt;= given axis (they get flattened).</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;axis&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span><span class="mi">-1</span><span class="p">);</span> <span class="c1">// Marian softmax defaults to last axis. @TODO: update if we ever add an axis_ parameter.</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;rows&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// becomes Gather</span>
      <span class="c1">// Example, adopted from ONNX docs:</span>
      <span class="c1">//  axis = 0</span>
      <span class="c1">//  data = [ [1.0, 1.2], [2.3, 3.4], [4.5, 5.7], ]</span>
      <span class="c1">//  indices = [ 0, 1, 1, 2, ]</span>
      <span class="c1">//  output = [  [1.0, 1.2], [2.3, 3.4], [2.3, 3.4], [4.5, 5.7], ]</span>
      <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Unexpected input shape for rows()&quot;</span><span class="p">);</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;axis&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// slice attributes (starts, ends)</span>
    <span class="n">Slice</span> <span class="n">slice</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="o">::</span><span class="n">tryGetSliceAttribute</span><span class="o">&lt;</span><span class="n">SliceViewNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">slice</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;starts&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">slice</span><span class="p">.</span><span class="n">begin</span><span class="p">});</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;ends&quot;</span>  <span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">slice</span><span class="p">.</span><span class="n">end</span><span class="p">});</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;steps&quot;</span> <span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">{(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">slice</span><span class="p">.</span><span class="n">stride</span><span class="p">});</span>
    <span class="p">}</span>
    <span class="c1">// shift attributes (shift, padValue)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shifts</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">padValue</span><span class="p">{};</span> <span class="c1">// (compiler bug: without initialization, I get an uninit warning, yet it is correctly set)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="o">::</span><span class="n">tryGetShiftAttributes</span><span class="o">&lt;</span><span class="n">ShiftNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">padValue</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pads</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">shift</span> <span class="p">:</span> <span class="n">shifts</span><span class="p">)</span>
        <span class="n">pads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shift</span><span class="p">);</span>   <span class="c1">// shift = #padValues to insert at front (or, for, shift &lt; 0, to remove at front)</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">shift</span> <span class="p">:</span> <span class="n">shifts</span><span class="p">)</span>
        <span class="n">pads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">);</span>  <span class="c1">// and #values to remove at end (or, for, shift &lt; 0, to insert at end)</span>
      <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">pads</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">expr</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Unexpected number of shift dimensions&quot;</span><span class="p">);</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;pads&quot;</span><span class="p">,</span> <span class="n">pads</span><span class="p">);</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="n">padValue</span><span class="p">);</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;mode&quot;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;constant&quot;</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// matmul attributes</span>
    <span class="kt">bool</span> <span class="n">transA</span><span class="p">,</span> <span class="n">transB</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">scalar</span><span class="p">;</span>
    <span class="c1">// @BUGBUG: I cannot get Gemm to work, ONNX runtime always crashes. So we will NEVER get here.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">op_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;Gemm&quot;</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// we get here for affine() or dot()</span>
      <span class="c1">// Note: We only get here if Gemm can implement this configuration.</span>
      <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span>
               <span class="p">(</span><span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">),</span>
               <span class="s">&quot;Gemm unexpectedly used for non-matrix inputs&quot;</span><span class="p">);</span>
      <span class="n">E</span><span class="o">::</span><span class="n">tryGetMatMulAttributes</span><span class="o">&lt;</span><span class="n">AffineNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">E</span><span class="o">::</span><span class="n">tryGetMatMulAttributes</span><span class="o">&lt;</span><span class="n">DotNodeOp</span><span class="o">&gt;</span>   <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span> <span class="o">||</span> <span class="n">E</span><span class="o">::</span><span class="n">fail</span><span class="p">();</span>
      <span class="cm">/*if (transA)        */</span> <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;transA&quot;</span><span class="p">,</span> <span class="n">transA</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
      <span class="cm">/*if (transB)        */</span> <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;transB&quot;</span><span class="p">,</span> <span class="n">transB</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
      <span class="cm">/*if (scalar != 1.0f)*/</span> <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;alpha&quot;</span><span class="p">,</span> <span class="n">scalar</span><span class="p">);</span>
      <span class="c1">//addAttribute(node, &quot;beta&quot;, 0.0f);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="o">::</span><span class="n">tryGetMatMulAttributes</span><span class="o">&lt;</span><span class="n">DotNodeOp</span><span class="o">&gt;</span>       <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">scalar</span><span class="p">)</span> <span class="o">||</span>
             <span class="n">E</span><span class="o">::</span><span class="n">tryGetMatMulAttributes</span><span class="o">&lt;</span><span class="n">DotBatchedNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">transA</span><span class="p">,</span> <span class="n">transB</span><span class="p">,</span> <span class="n">scalar</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// transpose/scalar not supported by ONNX MatMul, must have been expanded before we get here</span>
      <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">transA</span> <span class="o">||</span> <span class="n">transB</span> <span class="o">||</span> <span class="n">scalar</span> <span class="o">!=</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="s">&quot;Unexpected transpose or scalar attributes for {}&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="c1">// epsilon attribute</span>
    <span class="kt">float</span> <span class="n">epsilon</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="o">::</span><span class="n">tryGetEpsilonAttribute</span><span class="o">&lt;</span><span class="n">LayerNormalizationOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;epsilon&quot;</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// dropout patches</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">op_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;Sub&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;const&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;opRandomUniform_&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// @HACKHACK 1: For dropout, we route a &quot;&lt;&quot; operation through a Marian &quot;-&quot; because it has no &quot;&lt;&quot;.</span>
      <span class="o">*</span><span class="n">node</span><span class="p">.</span><span class="n">mutable_op_type</span><span class="p">()</span> <span class="o">=</span> <span class="s">&quot;Less&quot;</span><span class="p">;</span>
      <span class="c1">// Note: Since this is a hack, we don&#39;t bother to fix up the node name, which is still opSub_ID.</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;const&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">expr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;opRandomUniform_&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// @HACKHACK 2: The dropout weight, which is a &#39;const&#39; in Marian, acts as a placeholder for</span>
      <span class="c1">// a RandomUniform operation. In place of a &#39;const&#39;, we generate a uniform(0,1) node</span>
      <span class="c1">// of the same shape.</span>
      <span class="o">*</span><span class="n">node</span><span class="p">.</span><span class="n">mutable_op_type</span><span class="p">()</span> <span class="o">=</span> <span class="s">&quot;RandomUniform&quot;</span><span class="p">;</span>
      <span class="n">addAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;shape&quot;</span><span class="p">,</span> <span class="n">getExprShape</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// serialize the nodesForward_ of a graph right after build() into an ONNX-formatted file</span>
  <span class="c1">// We declare this to be ONNX operator set 9. @TODO: Which ONNX version does this correspond to?</span>
  <span class="c1">// The nodes must only contain operations supported by ONNX, so the caller must first call</span>
  <span class="c1">// expandMacroOpsForONNX().</span>
  <span class="c1">// One batch axis can be variable-length. It is recognized via a hack: by a special</span>
  <span class="c1">// dimension value that otherwise never naturally occurs, e.g. a larger prime number.</span>
  <span class="c1">// We will not recognize derivates of this value, such as value+1 or value x another dimension.</span>
  <span class="c1">// @TODO: This presently does not support variable batch dimensions. How does ONNX handle them?</span>
  <span class="c1">// @TODO: How to handle guided alignment? That&#39;s another input. Name? Shape?</span>
  <span class="c1">// This is based on the simple example in</span>
  <span class="c1">// https://github.com/onnx/onnx/blob/master/onnx/examples/make_model.ipynb</span>
  <span class="kt">void</span> <span class="n">ExpressionGraphONNXExporter</span><span class="o">::</span><span class="n">serializeToONNX</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fileRoot</span><span class="p">,</span> <span class="n">FunctionDefs</span><span class="o">&amp;&amp;</span> <span class="n">functionDefs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sentinelDim</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">GOOGLE_PROTOBUF_VERIFY_VERSION</span><span class="p">;</span>

    <span class="c1">// @TODO: expansion must deal with multiple sub-tapes (encoder, init)</span>
    <span class="c1">// expand Marian macro operations such as &quot;highway&quot; or &quot;scalar_add&quot; that ONNX does not have</span>
    <span class="c1">// After this, nodesForward_ is not topologically sorted.</span>
    <span class="n">expandMacroOpsForONNX</span><span class="p">(</span><span class="n">functionDefs</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">functionDef</span> <span class="p">:</span> <span class="n">functionDefs</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">graphName</span> <span class="o">=</span> <span class="n">functionDef</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
      <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">inputDefs</span>  <span class="o">=</span> <span class="n">functionDef</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
      <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">outputDefs</span> <span class="o">=</span> <span class="n">functionDef</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

      <span class="c1">// some stats</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;[onnx] Exporting graph {}&quot;</span><span class="p">,</span> <span class="n">graphName</span><span class="p">);</span>

      <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Expr</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">nameOverrides</span><span class="p">;</span> <span class="c1">// we implant input and output names dynamically (instead of setting the name in Expr)</span>

      <span class="c1">// clear memoization caches</span>
      <span class="n">tensors_</span><span class="o">-&gt;</span><span class="n">clearShorttermMemory</span><span class="p">();</span>
      <span class="n">tensors_</span><span class="o">-&gt;</span><span class="n">clearLongtermMemory</span><span class="p">();</span>

      <span class="c1">// create new dummy const nodes for all function arguments</span>
      <span class="c1">// These nodes will be replaced in rebuildNodesForward() and act as recursion stops.</span>
      <span class="c1">// The actual child references are NOT replaced.</span>
      <span class="c1">// Also, we collect the nameOverrides for all input and output nodes.</span>
      <span class="n">InputsMap</span> <span class="n">inputsMap</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">inputDef</span> <span class="p">:</span> <span class="n">inputDefs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">input</span> <span class="o">=</span> <span class="n">inputDef</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">inputsMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="o">!=</span> <span class="n">inputsMap</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">&quot;Duplicate inputDef expr??&quot;</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">constant</span><span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span> <span class="n">inits</span><span class="o">::</span><span class="n">zeros</span><span class="p">(),</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">value_type</span><span class="p">());</span>
        <span class="n">inputsMap</span><span class="p">[</span><span class="n">input</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
        <span class="n">nameOverrides</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputDef</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">outputDef</span> <span class="p">:</span> <span class="n">outputDefs</span><span class="p">)</span>
          <span class="n">nameOverrides</span><span class="p">[</span><span class="n">inputsMap</span><span class="p">(</span><span class="n">outputDef</span><span class="p">.</span><span class="n">second</span><span class="p">)]</span> <span class="o">=</span> <span class="n">outputDef</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>

      <span class="c1">// regenerate nodesForward_ from the roots, only for the function under consideration</span>
      <span class="c1">// This redirects all items in inputsMap in the graph and in outputDefs as well.</span>
      <span class="c1">// I.e. actual inputs are already replaced by Constants on the tape, but other nodes&#39;</span>
      <span class="c1">// references are not!</span>
      <span class="c1">// All references from this point on have to be run through inputsMap().</span>
      <span class="n">rebuildNodesForward</span><span class="p">(</span><span class="n">inputsMap</span><span class="p">,</span> <span class="n">outputDefs</span><span class="p">);</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;[graph] Topologically sorted, garbage-collected graph has size {}&quot;</span><span class="p">,</span> <span class="n">nodesForward_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

      <span class="c1">// sanity check: is the tape consistent, assuming the inputsMap?</span>
      <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="n">nodesOnTape</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">nodesForward_</span><span class="p">)</span>
        <span class="n">nodesOnTape</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">nodesForward_</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodesOnTape</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">nodesOnTape</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
          <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;Redirected child: {}, {}&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">(),</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">());</span>
        <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">nodesOnTape</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">inputsMap</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">==</span> <span class="n">nodesOnTape</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                 <span class="s">&quot;Node {} {} refers to child {} {} that is off tape??&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">(),</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">(),</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">(),</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">());</span>
      <span class="p">}</span>

      <span class="c1">// sanity check: did we consume all expected inputs?</span>
      <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="n">mappedInputSet</span><span class="p">;</span>  <span class="c1">// set of replacement Exprs (those constants) for inputs</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">ee</span> <span class="p">:</span> <span class="n">inputsMap</span><span class="p">)</span>
        <span class="n">mappedInputSet</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ee</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="n">seenMappedInputs</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">expr</span> <span class="p">:</span> <span class="n">nodesForward_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">inputsMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">inputsMap</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">&quot;An input node (id={}) was not mapped??&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="o">-&gt;</span><span class="n">getId</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mappedInputSet</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mappedInputSet</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
          <span class="n">seenMappedInputs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">mappedInputSet</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">seenMappedInputs</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">seenMappedInputs</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;WARNING: Input {} not consumed in input graph&quot;</span><span class="p">,</span> <span class="n">nameOverrides</span><span class="p">[</span><span class="n">e</span><span class="p">]);</span>
          <span class="n">nodesForward_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//ABORT_IF(seenMappedInputs.find(e) == seenMappedInputs.end(), &quot;Input node {} not found in input graph??&quot;, nameOverrides[e]);</span>

      <span class="c1">// output set -- these nodes are exported differently</span>
      <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="n">outputsSet</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">outputDef</span> <span class="p">:</span> <span class="n">outputDefs</span><span class="p">)</span>
        <span class="n">outputsSet</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">inputsMap</span><span class="p">(</span><span class="n">outputDef</span><span class="p">.</span><span class="n">second</span><span class="p">));</span>

      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ValueInfoProto</span><span class="o">&gt;</span> <span class="n">inputsParamsAndConstants</span><span class="p">;</span> <span class="c1">// parameters and constants all are considered inputs, just with initializers</span>

      <span class="c1">// Create a the nodes -&gt; array of NodeProto</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NodeProto</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TensorProto</span><span class="o">&gt;</span> <span class="n">initializers</span><span class="p">;</span> <span class="c1">// constants are inputs with initializers that hold their values. They go here.</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ValueInfoProto</span><span class="o">&gt;</span> <span class="n">shapeInfos</span><span class="p">;</span> <span class="c1">// expected shapes of operations (for diagnostics only)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ValueInfoProto</span><span class="o">&gt;</span> <span class="n">outputs</span><span class="p">;</span> <span class="c1">// outputs&#39; shapes</span>
      <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">expr</span> <span class="p">:</span> <span class="n">nodesForward_</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//LOG(info, &quot;exporting node name {} op {} ({})&quot;, getExprName(expr), E::mapExprOp(expr), expr-&gt;children().size());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;param&quot;</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;const&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">expr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">().</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;opRandomUniform_&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// leaves are not nodes in ONNX (except for the uniform placeholder @HACKHACK 2)</span>
          <span class="c1">//LOG(info, &quot;exporting leaf name {} op {} ({})&quot;, getExprName(expr), E::mapExprOp(expr), expr-&gt;children().size());</span>
          <span class="k">auto</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">getExprShape</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
          <span class="n">inputsParamsAndConstants</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">makeValueInfoProto</span><span class="p">(</span><span class="n">getExprName</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">nameOverrides</span><span class="p">),</span> <span class="n">getExprDataType</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">shape</span><span class="p">,</span> <span class="n">sentinelDim</span><span class="p">));</span>
          <span class="c1">// don&#39;t create an initializers entry for inputs</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">any_of</span><span class="p">(</span><span class="n">inputsMap</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">inputsMap</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Expr</span><span class="p">,</span> <span class="n">Expr</span><span class="o">&gt;&amp;</span> <span class="n">inputMap</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">inputMap</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="n">expr</span><span class="p">;</span>
              <span class="p">}))</span> <span class="p">{</span> <span class="c1">// skip designated inputs</span>
            <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;const&quot;</span><span class="p">,</span> <span class="s">&quot;Data inputs must be &#39;const&#39; nodes&quot;</span><span class="p">);</span>
            <span class="c1">//LOG(info, &quot;No initializer for data-input node {}&quot;, getExprName(expr));</span>
            <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// run initializers, to realize value of consts (params already got theirs)</span>
          <span class="n">expr</span><span class="o">-&gt;</span><span class="n">allocate</span><span class="p">();</span>
          <span class="n">expr</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">();</span>
          <span class="n">expr</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">();</span>
          <span class="n">ABORT_IF</span><span class="p">(</span><span class="o">!</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">(),</span> <span class="s">&quot;Leaf &#39;{}&#39; of type {} unexpectedly lacks a value despite trying really hard&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">(),</span> <span class="n">expr</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span>
          <span class="n">initializers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">makeExprTensorProto</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">nameOverrides</span><span class="p">));</span>
          <span class="k">continue</span><span class="p">;</span>      <span class="c1">// parameters must become initializers, name=input name</span>
        <span class="p">}</span>
        <span class="n">addExprNode</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">inputsParamsAndConstants</span><span class="p">,</span> <span class="n">initializers</span><span class="p">,</span> <span class="n">nameOverrides</span><span class="p">,</span> <span class="n">inputsMap</span><span class="p">,</span> <span class="n">sentinelDim</span><span class="p">);</span>
        <span class="n">logNode</span><span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">getExprShape</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">sentinelDim</span><span class="p">);</span>

        <span class="k">auto</span> <span class="n">valueInfo</span> <span class="o">=</span> <span class="n">makeValueInfoProto</span><span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">name</span><span class="p">(),</span> <span class="n">getExprDataType</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">getExprShape</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">sentinelDim</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">outputsSet</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">outputsSet</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
          <span class="n">outputs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">valueInfo</span><span class="p">);</span>
        <span class="c1">//else // we add expected-shape information, to more easily be able to track down where it may fail</span>
        <span class="c1">//  shapeInfos.push_back(valueInfo);</span>
      <span class="p">}</span>

      <span class="c1">//LOG(info, &quot;total nodes: {}, incl. {} inputs, {} op shapes&quot;, nodesForward_.size(), inputs.size(), shapeInfos.size());</span>

      <span class="c1">// @TODO: write a log message with the inputs and output names (the function signature)</span>

      <span class="c1">// Create the graph -&gt; GraphProto</span>
      <span class="k">auto</span> <span class="n">graphDef</span> <span class="o">=</span> <span class="n">makeGraph</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">graphName</span><span class="p">,</span> <span class="n">inputsParamsAndConstants</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">initializers</span><span class="p">,</span> <span class="n">shapeInfos</span><span class="p">);</span>

      <span class="c1">// Create the model -&gt; ModelProto</span>
      <span class="k">auto</span> <span class="n">modelDef</span> <span class="o">=</span> <span class="n">makeModel</span><span class="p">(</span><span class="n">graphDef</span><span class="p">,</span> <span class="cm">/*producer_name=*/</span><span class="s">&quot;Marian &quot;</span> <span class="o">+</span> <span class="n">buildVersion</span><span class="p">());</span>

      <span class="c1">// save it</span>
      <span class="k">auto</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">fileRoot</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">graphName</span> <span class="o">+</span> <span class="s">&quot;.onnx&quot;</span><span class="p">;</span>
      <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">modelDef</span><span class="p">.</span><span class="n">SerializeAsString</span><span class="p">();</span>
      <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">(),</span> <span class="s">&quot;Failed to serialize ONNX graph to string buffer&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">o</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
      <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">fail</span><span class="p">(),</span> <span class="s">&quot;Failed to create ONNX model file {}&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
      <span class="n">o</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
      <span class="n">o</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
      <span class="n">ABORT_IF</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">fail</span><span class="p">(),</span> <span class="s">&quot;Failed to write ONNX model to {}&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;[onnx] ONNX graph &#39;{}&#39; written to {}&quot;</span><span class="p">,</span> <span class="n">graphName</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// tape has been destroyed many times, so clear it for good</span>
    <span class="n">nodesForward_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">Expr</span> <span class="n">ExpressionGraphONNXExporter</span><span class="o">::</span><span class="n">tryFindForwardNodeByName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">nodeName</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">nodesForward_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nodesForward_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Expr</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="n">nodeName</span><span class="p">;</span> <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">nodesForward_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace marian</span>

<span class="cp">#endif </span><span class="c1">// USE_ONNX</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Marian NMT Team.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>