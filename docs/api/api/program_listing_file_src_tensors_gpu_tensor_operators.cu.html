<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File tensor_operators.cu &mdash; Marian NMT v1.10.28 2022-01-28 documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="canonical" href="http://marian-nmt.github.io/docs/api/api/program_listing_file_src_tensors_gpu_tensor_operators.cu.html" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Marian NMT
          </a>
              <div class="version">
                v1.10.28
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../graph.html">Expression graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../operators.html">Operations in the expression graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../layer.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factors.html">Using Marian with factors</a></li>
<li class="toctree-l1"><a class="reference internal" href="library_index.html">Library API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">How to contribute to Marian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc_guide.html">Writing documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Marian NMT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Program Listing for File tensor_operators.cu</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/program_listing_file_src_tensors_gpu_tensor_operators.cu.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-tensor-operators-cu">
<span id="program-listing-file-src-tensors-gpu-tensor-operators-cu"></span><h1>Program Listing for File tensor_operators.cu<a class="headerlink" href="#program-listing-for-file-tensor-operators-cu" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_tensors_gpu_tensor_operators.cu.html#file-src-tensors-gpu-tensor-operators-cu"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/tensors/gpu/tensor_operators.cu</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;common/types.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;tensors/tensor_operators.h&quot;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;functional/functional.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;functional/tensor.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;tensors/allocator.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;tensors/gpu/backend.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;tensors/gpu/cuda_helpers.h&quot;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;tensors/gpu/add_all.h&quot;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">marian</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">gpu</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">atomics</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">atomicAdd</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//*address += val;</span>
<span class="w">  </span><span class="o">::</span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#if COMPILE_FP16</span>
<span class="c1">// @TODO: copied from CuTorch, adapt this better, give credit.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">half</span><span class="w"> </span><span class="o">*</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">half</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//*address += val;</span>

<span class="cp">#if __CUDA_ARCH__ &gt;= 700 &amp;&amp; CUDA_VERSION &gt;= 10000 </span><span class="c1">// compute capability 70 and higher with CUDA 10</span>
<span class="w">  </span><span class="o">::</span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="cp">#else </span><span class="c1">// __CUDA_ARCH__ &lt; 700</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">address_as_ui</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">address</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">address_as_ui</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">assumed</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assumed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#if CUDA_VERSION &lt; 9000</span>
<span class="w">    </span><span class="n">half</span><span class="w"> </span><span class="n">hsum</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">hsum</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">address</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">old</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">old</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffff</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">hsum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hsum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="cp">#else</span>
<span class="w">    </span><span class="n">__half_raw</span><span class="w"> </span><span class="n">hsum</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">hsum</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">address</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">old</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">old</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffff</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">half</span><span class="w"> </span><span class="n">tmpres</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hsum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">hsum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__half_raw</span><span class="p">(</span><span class="n">tmpres</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="cp">#endif</span>
<span class="w">    </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">address</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">old</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffff</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">hsum</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">old</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffff0000</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">hsum</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicCAS</span><span class="p">(</span><span class="n">address_as_ui</span><span class="p">,</span><span class="w"> </span><span class="n">assumed</span><span class="p">,</span><span class="w"> </span><span class="n">old</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">assumed</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">old</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="c1">// __CUDA_ARCH__</span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gIsNaN</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isNaN</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isInf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">isnan</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">in</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span><span class="w"> </span><span class="o">*</span><span class="n">isNaN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">isinf</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">in</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span><span class="w"> </span><span class="o">*</span><span class="n">isInf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">IsNaN</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allocator</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&amp;</span><span class="w"> </span><span class="n">isNaN</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&amp;</span><span class="w"> </span><span class="n">isInf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">dIsNaN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">dIsInf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">()[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">fill</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">getBackend</span><span class="p">(),</span><span class="w"> </span><span class="n">dIsNaN</span><span class="p">,</span><span class="w"> </span><span class="n">dIsNaN</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gIsNaN</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">dIsNaN</span><span class="p">,</span><span class="w"> </span><span class="n">dIsInf</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gIsNaN</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">dIsNaN</span><span class="p">,</span><span class="w"> </span><span class="n">dIsInf</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;IsNaN for type {} not implemented&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">CudaCopy</span><span class="p">(</span><span class="n">dIsNaN</span><span class="p">,</span><span class="w"> </span><span class="n">dIsNaN</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">isNaN</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">CudaCopy</span><span class="p">(</span><span class="n">dIsInf</span><span class="p">,</span><span class="w"> </span><span class="n">dIsInf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">isInf</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">To</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">From</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gCopyCastTo</span><span class="p">(</span><span class="n">To</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">From</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">add</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">To</span><span class="p">)</span><span class="n">in</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">To</span><span class="p">)</span><span class="n">in</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">To</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">From</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">CopyCastTo</span><span class="p">(</span><span class="n">To</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">From</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">gCopyCastTo</span><span class="o">&lt;</span><span class="n">add</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">CopyCastFrom</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastTo</span><span class="o">&lt;</span><span class="n">add</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastTo</span><span class="o">&lt;</span><span class="n">add</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastTo</span><span class="o">&lt;</span><span class="n">add</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;CopyCastTo to type {} not implemented&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">CopyCast</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastFrom</span><span class="o">&lt;</span><span class="cm">/*add=*/</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastFrom</span><span class="o">&lt;</span><span class="cm">/*add=*/</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastFrom</span><span class="o">&lt;</span><span class="cm">/*add=*/</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">uint32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastFrom</span><span class="o">&lt;</span><span class="cm">/*add=*/</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;CopyCastFrom from type {} not implemented&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">AddCast</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastFrom</span><span class="o">&lt;</span><span class="cm">/*add=*/</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastFrom</span><span class="o">&lt;</span><span class="cm">/*add=*/</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastFrom</span><span class="o">&lt;</span><span class="cm">/*add=*/</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">uint32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CopyCastFrom</span><span class="o">&lt;</span><span class="cm">/*add=*/</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;CopyCastFrom from type {} not implemented&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">ConcatCont</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">axis</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">axis</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">step</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">step</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">step</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeOf</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset1</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset2</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">cudaMemcpyDeviceToDevice</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="n">offset1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gInsertCols</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols_out</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols_in</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset_out</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// @TODO: change to if j == rows then break, as that&#39;s what it means. In 4 functions in here.</span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset_out</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset_in</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">add</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rowIn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowIn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Special version for axis = -1 @TODO: write common better version</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Concatenate1</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">inputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">rows</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">(),</span><span class="w"></span>
<span class="w">             </span><span class="s">&quot;First dimension must be equal&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cols_in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols_in</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gInsertCols</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols_in</span><span class="p">,</span><span class="w"> </span><span class="n">cols_out</span><span class="p">,</span><span class="w"> </span><span class="n">cols_in</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gInsertCols</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols_in</span><span class="p">,</span><span class="w"> </span><span class="n">cols_out</span><span class="p">,</span><span class="w"> </span><span class="n">cols_in</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Concatenate1 not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">cols_in</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gJoin2</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rowBatch</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in1</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">size_t</span><span class="w"> </span><span class="n">inStride1</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in2</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">size_t</span><span class="w"> </span><span class="n">inStride2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">outStride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inStride1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inStride2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowBatch</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">outStride</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">curBatch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">outStride</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">curPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">outStride</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jIn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">curBatch</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inStride1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">curPos</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jIn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">curBatch</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inStride2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">curPos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">inStride1</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowIn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">jIn1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowIn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">jIn2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">curPos</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">inStride1</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowIn1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowIn2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Special version for axis = -2 @TODO: write common better version</span>
<span class="kt">void</span><span class="w"> </span><span class="n">Concatenate2</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in1</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rowStride1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in1</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-2</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rowStride2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in2</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-2</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rowBatch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-2</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cols</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">gJoin2</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">rowBatch</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">in1</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">rowStride1</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">in2</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">rowStride2</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">gJoin2</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">rowBatch</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">in1</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">rowStride1</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">in2</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">rowStride2</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Concatenate2 not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Concatenate</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">ax</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">Concatenate1</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">inputs</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">ax</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">Concatenate2</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="n">ConcatCont</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="n">ax</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Split1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">outputs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols_in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">outputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">rows</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">(),</span><span class="w"></span>
<span class="w">             </span><span class="s">&quot;First dimension must be equal&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cols_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols_out</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gInsertCols</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols_out</span><span class="p">,</span><span class="w"> </span><span class="n">cols_out</span><span class="p">,</span><span class="w"> </span><span class="n">cols_in</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gInsertCols</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols_out</span><span class="p">,</span><span class="w"> </span><span class="n">cols_out</span><span class="p">,</span><span class="w"> </span><span class="n">cols_in</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Split1 not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">cols_out</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// @TODO: this function is just a temporary fix until I come up with</span>
<span class="c1">// something better for the situation below.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gAddRow</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">SplitCont</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">outputs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">axis</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">axis</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">step</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">offset1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">step</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">outputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">step</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">offset2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// BUG: this is does not add gradients</span>
<span class="w">      </span><span class="c1">// cudaMemcpyAsync(out-&gt;data() + offset2,</span>
<span class="w">      </span><span class="c1">//                in-&gt;data() + offset1,</span>
<span class="w">      </span><span class="c1">//                size * sizeof(float),</span>
<span class="w">      </span><span class="c1">//                cudaMemcpyDeviceToDevice);</span>

<span class="w">      </span><span class="c1">// @TODO: this is a quick but bad fix for the above bug</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">gAddRow</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset2</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset1</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">gAddRow</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset2</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset1</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;SplitCont not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">offset1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Deconcatenate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">outputs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">ax</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">Split1</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="n">SplitCont</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">ax</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gTransposeND</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">functional</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">permute</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="o">::</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">functional</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">oDims</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">functional</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pDims</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="p">.</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="p">.</span><span class="n">shape</span><span class="p">().</span><span class="n">dims</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">oDims</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">pDims</span><span class="p">[</span><span class="n">permute</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oDims</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">inIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">shape</span><span class="p">().</span><span class="n">index</span><span class="p">(</span><span class="n">pDims</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// TODO: operates on raw indices, change to</span>
<span class="w">      </span><span class="c1">// converting Tensor::operator[]</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">add</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">.</span><span class="n">data</span><span class="p">()[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">data</span><span class="p">()[</span><span class="n">inIndex</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="p">.</span><span class="n">data</span><span class="p">()[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="n">data</span><span class="p">()[</span><span class="n">inIndex</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gTranspose0213</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="kt">int</span><span class="w"> </span><span class="n">stride1</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="kt">int</span><span class="w"> </span><span class="n">stride2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stride1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">stride2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">stride</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">stride</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">stride1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">stride</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">stride1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">j2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">stride</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">stride2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">add</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rowIn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowIn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">TransposeND</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vAxis</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">vAxis</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">stride1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-2</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">stride2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-3</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gTranspose0213</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">stride1</span><span class="p">,</span><span class="w"> </span><span class="n">stride2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">uint32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gTranspose0213</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">stride1</span><span class="p">,</span><span class="w"> </span><span class="n">stride2</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gTranspose0213</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">stride1</span><span class="p">,</span><span class="w"> </span><span class="n">stride2</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Transpose for type {} not implemented&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">functional</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">axes</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vAxis</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">axes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">diff</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vAxis</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">diff</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diff</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"></span>
<span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gTransposeND</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">axes</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">uint32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gTransposeND</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">axes</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gTransposeND</span><span class="o">&lt;</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">half</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">axes</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Transpose for type {} not implemented&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//@TODO: code duplication?</span>
<span class="kt">void</span><span class="w"> </span><span class="n">TransposeNDGrad</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">vAxis</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">vAxis</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">stride1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-2</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">stride2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-3</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gTranspose0213</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">stride1</span><span class="p">,</span><span class="w"> </span><span class="n">stride2</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gTranspose0213</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">stride1</span><span class="p">,</span><span class="w"> </span><span class="n">stride2</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Transpose for type {} not implemented&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">functional</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">axes</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vAxis</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">axes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">diff</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vAxis</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">diff</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diff</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gTransposeND</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">axes</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">gTransposeND</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">half</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">axes</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Transpose for type {} not implemented&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Computes the softmax</span>
<span class="c1">// in - input tensor</span>
<span class="c1">// out - output tensor</span>
<span class="c1">// we compute the softmax over the the cols (last dimension)</span>
<span class="c1">// rows are time, batch or beam dimensions</span>
<span class="c1">// number of threads is number of cols or MAX_THREADS</span>
<span class="c1">// number of blocks is number of rows or MAX_BLOCKS</span>
<span class="c1">// @TODO: handle half2</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gSoftmax</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">outShape</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">functional</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// loop over blocks of rows</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// blockIdx.x - row index (within block of rows)</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// compute softmax over one row, row elements distributed over threads</span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="c1">// pointer to row input data</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// CUDA complains if type or size of shared memory changes, keep size constant.</span>
<span class="w">      </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">_sharedBytes</span><span class="p">[];</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">_share</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_shareAccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// determine max (used below to improve numeric stability)</span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_share</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// @TODO: what&#39;s going on here with fp16?</span>
<span class="w">      </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">CUDA_FLT_MAX</span><span class="p">;</span><span class="w">  </span><span class="c1">// mask</span>
<span class="w">      </span><span class="c1">// find max over column indices that have the same relative column index (=threadIdx.x) across all blocks of columns</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// threadIdx.x = column index within block of columns; we reduce over columns within a block, then over blocks</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">])</span><span class="w"></span>
<span class="w">            </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="c1">// max over columns within a column block via tree reduction</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="c1">// compute denominator</span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_shareAccType</span><span class="p">;</span><span class="w"> </span><span class="c1">// accumulate into AccType</span>
<span class="w">      </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// @TODO: is it faster to cache the result of expf() in GPU RAM, or would it be faster to recompute it below?</span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">exp</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">max</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">so</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">ex</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">ex</span><span class="p">;</span><span class="w"> </span><span class="c1">// accumulate into AccType</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="c1">// now reduce over all columns within the block</span>
<span class="w">      </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="c1">// produce final output data</span>
<span class="w">      </span><span class="n">AccType</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">so</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)((</span><span class="n">AccType</span><span class="p">)</span><span class="n">so</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w"> </span><span class="c1">// divide as AccType then convert</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Softmax</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">m</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">;</span><span class="w">  </span><span class="c1">// accumulate into float</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gSoftmax</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gSoftmax</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Softmax not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gSinusoidalPositionEmbeddings</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                              </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">outShape</span><span class="p">,</span><span class="w"></span>
<span class="w">                                              </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">functional</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">numTimescales</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">cols</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.f</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">logTimescaleIncrement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ops</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">log</span><span class="p">(</span><span class="mf">10000.f</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">numTimescales</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.f</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// loop over blocks of rows</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// blockIdx.x - row index (within block of rows)</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// compute softmax over one row, row elements distributed over threads</span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="c1">// pointer to row data</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Ops</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">exp</span><span class="p">((</span><span class="kt">float</span><span class="p">)(</span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">numTimescales</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="n">logTimescaleIncrement</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">outRow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">numTimescales</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">Ops</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">sin</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Ops</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">cos</span><span class="p">(</span><span class="n">v</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">SinusoidalPositionEmbeddings</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cols</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gSinusoidalPositionEmbeddings</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">start</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gSinusoidalPositionEmbeddings</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">start</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;SinusoidalPositionEmbeddings not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="c1">// @TODO: refactor to reuse code from softmax, add comments</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gLogSoftmax</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">outShape</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">functional</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// CUDA complains if type or size of shared memory changes, keep size constant.</span>
<span class="w">      </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">_sharedBytes</span><span class="p">[];</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">_share</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_shareAccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_share</span><span class="p">;</span><span class="w"> </span><span class="c1">// 16-bit is ok for max if applicable</span>
<span class="w">      </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">])</span><span class="w"></span>
<span class="w">            </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_shareAccType</span><span class="p">;</span><span class="w"> </span><span class="c1">// keep AccType for accumulation</span>

<span class="w">      </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">sm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">max</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">exp</span><span class="p">(</span><span class="n">sm</span><span class="p">);</span><span class="w"> </span><span class="c1">// sum with AccType</span>
<span class="w">          </span><span class="n">so</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sm</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w"> </span><span class="c1">// sum with AccType</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">so</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">log</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span><span class="w"> </span><span class="c1">// take log at the end and convert</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">LogSoftmax</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">m</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">;</span><span class="w"> </span><span class="c1">// use float32 as accumulation type</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLogSoftmax</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLogSoftmax</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;LogSoftmax not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gSoftmaxGrad</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">grad</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">      </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">_sharedBytes</span><span class="p">[];</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gradRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grad</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adjRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">valRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">valRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">adjRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"> </span><span class="c1">// accumulates in AccType</span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">valRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">AccType</span><span class="p">)</span><span class="n">adjRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">gradRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">val</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// @TODO: refactor with logsoftmax, add math</span>
<span class="kt">void</span><span class="w"> </span><span class="n">SoftmaxGrad</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">grad</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// grad and val are both m-by-k matrices, passed as input.</span>
<span class="w">  </span><span class="c1">// A weighted average of each row of grad (according to the weights</span>
<span class="w">  </span><span class="c1">// specified in val) is computed and subtracted from Out.</span>
<span class="w">  </span><span class="c1">// adj is multiplied for each element to get backward step in autodiff</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gSoftmaxGrad</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">val</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Accumulate into float</span>
<span class="w">    </span><span class="n">gSoftmaxGrad</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">val</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;SoftmaxGrad not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gLogSoftmaxGrad</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">grad</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">_sharedBytes</span><span class="p">[];</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gradRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grad</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adjRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">valRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">adjRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"> </span><span class="c1">// AccType</span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">gradRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)((</span><span class="n">AccType</span><span class="p">)</span><span class="n">adjRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">exp</span><span class="p">((</span><span class="n">AccType</span><span class="p">)</span><span class="n">valRow</span><span class="p">[</span><span class="n">id</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">LogSoftmaxGrad</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">grad</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// grad and val are both m-by-k matrices, passed as input.</span>
<span class="w">  </span><span class="c1">// A weighted average of each row of grad (according to the weights</span>
<span class="w">  </span><span class="c1">// specified in val) is computed and subtracted from Out.</span>
<span class="w">  </span><span class="c1">// adj is multiplied for each element to get backward step in autodiff</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">;</span><span class="w"> </span><span class="c1">// Use float32 as accumulation type</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLogSoftmaxGrad</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">val</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// accumulate into float</span>
<span class="w">    </span><span class="n">gLogSoftmaxGrad</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">val</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;LogSoftmaxGrad not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">grad</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gCopyRows</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">IndexType</span><span class="o">*</span><span class="w"> </span><span class="n">sourceRowIdx</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">dstId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">srcId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sourceRowIdx</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dstId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">srcId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowIn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">CopyRows</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">indices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="n">matchOrAbort</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rowsToCopy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rowsToCopy</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gCopyRows</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rowsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gCopyRows</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rowsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;CopyRows not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gPasteRows</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="k">const</span><span class="w"> </span><span class="n">IndexType</span><span class="o">*</span><span class="w"> </span><span class="n">targetRowIdx</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// index into &#39;indices&#39; vector</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">dstId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">targetRowIdx</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">srcId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dstId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">srcId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// aggregate the entire row</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// column index   --@TODO: column index should be called &#39;j&#39;</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Note: atomicAdd() not needed if number of blocks is 1. Avoid it because it is slow for fp16.</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rowIn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="n">atomics</span><span class="o">::</span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">rowOut</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">rowIn</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">PasteRows</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">indices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="n">matchOrAbort</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rowsToCopy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if 1   </span><span class="c1">// @TODO: make this configurable with a &#39;deterministic&#39; flag</span>
<span class="w">  </span><span class="c1">// If we only use one block, then each core operates on a different column,</span>
<span class="w">  </span><span class="c1">// hence the summation becomes deterministic.</span>
<span class="w">  </span><span class="c1">// However, we only use e.g. 512 cores out of possibly 3000+, so this will be</span>
<span class="w">  </span><span class="c1">// 6 x slower in this example.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rowsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gPasteRows</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rowsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gPasteRows</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rowsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;CopyRows not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gCopyCols</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">colsIn</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">IndexType</span><span class="o">*</span><span class="w"> </span><span class="n">sourceColIdx</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">colsOut</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">colsIn</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">colsOut</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">colsOut</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">colsOut</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowIn</span><span class="p">[</span><span class="n">sourceColIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">CopyCols</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">indices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">matchOrAbort</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">colsToCopy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">colsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rows</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gCopyCols</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">colsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gCopyCols</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">colsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;CopyCols not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gPasteCols</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="kt">size_t</span><span class="w"> </span><span class="n">colsOut</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="k">const</span><span class="w"> </span><span class="n">IndexType</span><span class="o">*</span><span class="w"> </span><span class="n">targetColIdx</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="kt">size_t</span><span class="w"> </span><span class="n">colsIn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">colsIn</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">colsOut</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">colsIn</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">colsIn</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">rowOut</span><span class="p">[</span><span class="n">targetColIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">rowIn</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="c1">// @TODO: atomicAdd?</span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">PasteCols</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">indices</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">matchOrAbort</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">colsToCopy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">colsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rows</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gPasteCols</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">colsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gPasteCols</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">colsToCopy</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;PasteCols not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gSelect</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">outShape</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">inShape</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="kt">int</span><span class="w"> </span><span class="n">axis</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">IndexType</span><span class="o">*</span><span class="w"> </span><span class="n">d_indices</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">idxShape</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">functional</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dims</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">outShape</span><span class="p">.</span><span class="n">dims</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">dims</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">idxIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idxShape</span><span class="p">.</span><span class="n">bindex</span><span class="p">(</span><span class="n">dims</span><span class="p">);</span><span class="w"> </span><span class="c1">// broadcast index into indices tensor</span>
<span class="w">      </span><span class="n">dims</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">d_indices</span><span class="p">[</span><span class="n">idxIndex</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">inIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inShape</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">dims</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="n">inIndex</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gInsert</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">outShape</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">inShape</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="kt">int</span><span class="w"> </span><span class="n">axis</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">IndexType</span><span class="o">*</span><span class="w"> </span><span class="n">d_indices</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">idxShape</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inShape</span><span class="p">.</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">functional</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dims</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">inShape</span><span class="p">.</span><span class="n">dims</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">dims</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">idxIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idxShape</span><span class="p">.</span><span class="n">bindex</span><span class="p">(</span><span class="n">dims</span><span class="p">);</span><span class="w"> </span><span class="c1">// broadcast index into indices tensor</span>
<span class="w">      </span><span class="n">dims</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">d_indices</span><span class="p">[</span><span class="n">idxIndex</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">outIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">dims</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="p">[</span><span class="n">outIndex</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"> </span><span class="c1">// this is probably wrong, atomicAdd?</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Select</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">axis</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">matchOrAbort</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">axisGPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gSelect</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">axisGPU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">());</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gSelect</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">axisGPU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">());</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">uint32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gSelect</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">axisGPU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                 </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Select not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Insert</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">axis</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">matchOrAbort</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">axisGPU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gInsert</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">axisGPU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">());</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gInsert</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">axisGPU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">());</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Insert not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gGRUFastForward</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xW</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">bool</span><span class="w"> </span><span class="k">final</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">mask</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xWrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xW</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sUrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sU</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">h</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="k">final</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">tanh</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">sUrow</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">l</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">tanh</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">l</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rowState</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rowState</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">GRUFastForward</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">final</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gGRUFastForward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                                </span><span class="c1">// output</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// state</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// xW</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// sU</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// b</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// mask</span>
<span class="w">        </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">final</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gGRUFastForward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                                </span><span class="c1">// output</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// state</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// xW</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// sU</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// b</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// mask</span>
<span class="w">        </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">final</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;GRUFastForward not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gGRUFastBackward</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outState</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outXW</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outSU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outB</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xW</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">bool</span><span class="w"> </span><span class="k">final</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">mask</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOutState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outState</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOutXW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outXW</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOutSU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outSU</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOutB</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">outB</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outB</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowXW</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">xW</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowSU</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">sU</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowAdj</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">rowXW</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rowSU</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">rowXW</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rowSU</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">h</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="k">final</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">tanh</span><span class="p">(</span><span class="n">rowXW</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">rowSU</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">l</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">tanh</span><span class="p">(</span><span class="n">rowXW</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rowSU</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">l</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowAdj</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">);</span><span class="w"></span>

<span class="w">          </span><span class="c1">// df/ds</span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outState</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutState</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// df/d(xW_r) ...</span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">dfdxW_r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="k">final</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">dfdxW_r</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">rowSU</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">l</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="k">else</span><span class="w"></span>
<span class="w">            </span><span class="n">dfdxW_r</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">rowSU</span><span class="p">[</span><span class="n">l</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outXW</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutXW</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dfdxW_r</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outSU</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutSU</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dfdxW_r</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outB</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dfdxW_r</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// df/d(xW_z) ...</span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">dfdxW_z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">rowState</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outXW</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutXW</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dfdxW_z</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outSU</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutSU</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dfdxW_z</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outB</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutB</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dfdxW_z</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// df/d(xW_x) ...</span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">dfdxW_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outXW</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutXW</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dfdxW_x</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outSU</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutSU</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dfdxW_x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outB</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="k">final</span><span class="p">)</span><span class="w"></span>
<span class="w">              </span><span class="n">rowOutB</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dfdxW_x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">else</span><span class="w"></span>
<span class="w">              </span><span class="n">rowOutB</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dfdxW_x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">GRUFastBackward</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allocator</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputs</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="kt">bool</span><span class="w"> </span><span class="k">final</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">Tensor</span><span class="w"> </span><span class="n">tempGradBias</span><span class="p">,</span><span class="w"> </span><span class="n">tempOnes</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MemoryPiece</span><span class="o">::</span><span class="n">PtrType</span><span class="w"> </span><span class="n">tempGradBiasMemory</span><span class="p">,</span><span class="w"> </span><span class="n">tempOnesMemory</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Shape</span><span class="w"> </span><span class="n">memShape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-1</span><span class="p">]};</span><span class="w"></span>

<span class="w">    </span><span class="n">tempGradBiasMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">memShape</span><span class="p">.</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeOf</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()));</span><span class="w"></span>
<span class="w">    </span><span class="n">tempGradBias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorBase</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">tempGradBiasMemory</span><span class="p">,</span><span class="w"> </span><span class="n">memShape</span><span class="p">,</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">(),</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getBackend</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">tempGradBias</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="mf">0.f</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">tempOnesMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">rows</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeOf</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()));</span><span class="w"></span>
<span class="w">    </span><span class="n">tempOnes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorBase</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">tempOnesMemory</span><span class="p">,</span><span class="w"> </span><span class="n">Shape</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">}),</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">(),</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getBackend</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">tempOnes</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="mf">1.f</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gGRUFastBackward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// state - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// xW - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// sU - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">tempGradBias</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">      </span><span class="c1">// b - adj</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// state</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// xW</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// sU</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// b</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// mask</span>
<span class="w">        </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">final</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gGRUFastBackward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// state - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// xW - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// sU - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">tempGradBias</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// b - adj</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// state</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// xW</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// sU</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// b</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// mask</span>
<span class="w">        </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">final</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;gGRUFastBackward not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// We use this go get rid of the atomicAdd and perform a reduce of the gradients afterwards.</span>
<span class="w">  </span><span class="c1">// This is much faster for fp16 which seems to have a broken atomicAdd implementation.</span>
<span class="w">  </span><span class="c1">// We reduce bias gradients with a matrix multiply, but use a 32-bit compute type.</span>
<span class="w">  </span><span class="c1">// This preserves precision with larger batches where all batch entries reduce into a single vector.</span>
<span class="w">  </span><span class="c1">// See also AffineNodeOp where we do the same for biases</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gpu</span><span class="o">::</span><span class="n">Prod</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">tempOnes</span><span class="p">,</span><span class="w"> </span><span class="n">tempGradBias</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">);</span><span class="w"> </span><span class="c1">// beta set to one to add</span>
<span class="w">    </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">tempGradBiasMemory</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">tempOnesMemory</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gCrossEntropyPick</span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">outShape</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">inShape</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">IndexType</span><span class="o">*</span><span class="w"> </span><span class="n">pick</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">AccType</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AccType</span><span class="p">(</span><span class="mf">0.f</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inShape</span><span class="p">.</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">inShape</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inShape</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">_sharedBytes</span><span class="p">[];</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">])</span><span class="w"></span>
<span class="w">            </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">_acc</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w">    </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">_acc</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">_acc</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w">    </span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">exp</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">max</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">_acc</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)(</span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">max</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">_acc</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w">    </span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_acc</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">)</span><span class="w">    </span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">_acc</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_acc</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="w"> </span><span class="n">sumexp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_acc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="c1">// H(u, p) = 1/N * logsoftmax(h) = mean(h - max) - log(sum(exp(h - max)))</span>
<span class="w">      </span><span class="n">AccType</span><span class="w"> </span><span class="n">mean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_acc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="c1">// mean(h - max)</span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pick</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">logsumexp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">log</span><span class="p">(</span><span class="n">sumexp</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">logsumexp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">max</span><span class="p">;</span><span class="w"> </span><span class="c1">// cross-entropy    H(y^, p)</span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">ls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">logsumexp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mean</span><span class="p">;</span><span class="w">                           </span><span class="c1">// label smoothing  H(u, p)</span>
<span class="w">          </span><span class="n">out</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ce</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ls</span><span class="p">;</span><span class="w">  </span><span class="c1">// (1 - alpha) * H(y^, p) + alpha * H(u, p)</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// In each j-th row, take the corresponding j-th label index i from indices and compute:</span>
<span class="c1">// For each vocabulary item v, the only non-zero element in a row in the sum is the item</span>
<span class="c1">// that matches the label indexed by i (the picked element).</span>
<span class="c1">// C = sum_{v in V}(-logsoftmax(A) * delta(v, i) = -logsoftmax(A)[i]</span>
<span class="kt">void</span><span class="w"> </span><span class="n">CrossEntropyPick</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">matchOrAbort</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Use float32 as accumulation type</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gCrossEntropyPick</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gCrossEntropyPick</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;CrossEntropyPick not implemented for input type {} and output type{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gCrossEntropyPickBackward</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="k">const</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">outShape</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="k">const</span><span class="w"> </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="k">const</span><span class="w"> </span><span class="n">IndexType</span><span class="o">*</span><span class="w"> </span><span class="n">pick</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">AccType</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AccType</span><span class="p">(</span><span class="mf">0.f</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">.</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">_sharedBytes</span><span class="p">[];</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">])</span><span class="w"></span>
<span class="w">            </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">exp</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">max</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="c1">// cross-entropy</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">sub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)(</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pick</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">dce</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">exp</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">max</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sub</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">dls</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">sub</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">so</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="n">adj</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">dce</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dls</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">CrossEntropyPickBackward</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">matchOrAbort</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">;</span><span class="w"> </span><span class="c1">// use float as accumulation type</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gCrossEntropyPickBackward</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gCrossEntropyPickBackward</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">indices</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">IndexType</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">labelSmoothingAlpha</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;CrossEntropyPickBackward not implemented for type {} and adjoint type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// computes the L2Norm of tensor and returns value as flaot on the CPU,</span>
<span class="c1">// this is mostly used for diagnostic purposes and gradient clipping</span>
<span class="kt">float</span><span class="w"> </span><span class="n">L2Norm</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allocator</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// @TODO: reverse order of arguments</span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">functional</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">l2Norm</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">l2Norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">AggregateAllAndReturn</span><span class="o">&lt;</span><span class="cm">/*ElementType=*/</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="cm">/*AccType=*/</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allocator</span><span class="p">,</span><span class="w"> </span><span class="cm">/*functor=*/</span><span class="n">_1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_1</span><span class="p">,</span><span class="w"> </span><span class="cm">/*aggInit=*/</span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="cm">/*aggFunctor=*/</span><span class="n">_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_2</span><span class="p">,</span><span class="w"> </span><span class="cm">/*scale=*/</span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">));</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">l2Norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">AggregateAllAndReturn</span><span class="o">&lt;</span><span class="cm">/*ElementType=*/</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="cm">/*AccType=*/</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allocator</span><span class="p">,</span><span class="w"> </span><span class="cm">/*functor=*/</span><span class="n">_1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_1</span><span class="p">,</span><span class="w"> </span><span class="cm">/*aggInit=*/</span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="cm">/*aggFunctor=*/</span><span class="n">_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_2</span><span class="p">,</span><span class="w"> </span><span class="cm">/*scale=*/</span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">));</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;L2Norm not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">l2Norm</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gAtt</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">va</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ctx</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w">  </span><span class="c1">// total rows (batch x time x beam)</span>
<span class="w">                     </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w">  </span><span class="c1">// depth</span>
<span class="w">                     </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w">  </span><span class="c1">// batch size</span>
<span class="w">                     </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w">   </span><span class="c1">// time of ctx</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">vaRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">va</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ctxRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">stateRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">j</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">))</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="n">AccType</span><span class="w"> </span><span class="n">_share</span><span class="p">[];</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_share</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.f</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">ctxRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">stateRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">tanh</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">vaRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Att</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">totalRows</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"> </span><span class="c1">// number of rows</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">modelDim</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-1</span><span class="p">];</span><span class="w">                          </span><span class="c1">// number of cols</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batchDim</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-2</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">contextWordsDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-3</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">totalRows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">modelDim</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gAtt</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">va</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">state</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">totalRows</span><span class="p">,</span><span class="w"> </span><span class="n">modelDim</span><span class="p">,</span><span class="w"> </span><span class="n">batchDim</span><span class="p">,</span><span class="w"> </span><span class="n">contextWordsDim</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gAtt</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">va</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">state</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">totalRows</span><span class="p">,</span><span class="w"> </span><span class="n">modelDim</span><span class="p">,</span><span class="w"> </span><span class="n">batchDim</span><span class="p">,</span><span class="w"> </span><span class="n">contextWordsDim</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;gAtt not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gAttBack</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gVa</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gContext</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gState</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">va</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w">  </span><span class="c1">// rows</span>
<span class="w">                         </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w">  </span><span class="c1">// cols</span>
<span class="w">                         </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w">   </span><span class="c1">// batch size</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gcRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gContext</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gsRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gState</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">cRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">tanh</span><span class="p">(</span><span class="n">z</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">va</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">);</span><span class="w"></span>

<span class="w">          </span><span class="n">gcRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"> </span><span class="c1">// atomicAdd? reasons for instabilities?</span>
<span class="w">          </span><span class="n">gsRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">atomics</span><span class="o">::</span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">gVa</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="w"> </span><span class="c1">// @TODO: get rid of atomicAdd via Matmul</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">AttBack</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">gVa</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gContext</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gState</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">Tensor</span><span class="w"> </span><span class="n">va</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">Tensor</span><span class="w"> </span><span class="n">context</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">Tensor</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-2</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">k</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">gVa</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gAttBack</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">gVa</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">gContext</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">gState</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">va</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">state</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">m</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">k</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">gVa</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gAttBack</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">gVa</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">gContext</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">gState</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">va</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">context</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">state</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                  </span><span class="n">m</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">k</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;gAttBack not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">gVa</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gLNormalization</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">AccType</span><span class="w"> </span><span class="n">eps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e-9</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">_sharedBytes</span><span class="p">[];</span><span class="w"></span>
<span class="w">  </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_shareAccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">AccType</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">yRow</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xRow</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_shareAccType</span><span class="p">;</span><span class="w"> </span><span class="c1">// accumulate into floats</span>
<span class="w">      </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">xRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="w"> </span><span class="n">mean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_sqSum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_shareAccType</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">_sqSum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">xv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">xRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xv</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mean</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">_sqSum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="n">_sqSum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_sqSum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="w"> </span><span class="n">sigma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_sqSum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">eps</span><span class="p">);</span><span class="w"> </span><span class="c1">// all AccType</span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">gammav</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">gamma</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">xv</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">xRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">betav</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">beta</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.f</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">lv</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">xv</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mean</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sigma</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">y</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">gammav</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">betav</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">yRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">LayerNormalization</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">Tensor</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="kt">float</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLNormalization</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">gamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">beta</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">beta</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">eps</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLNormalization</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">gamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">beta</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">beta</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">eps</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;LayerNormalization not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gLayerNormalizationGrad</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gradX</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gradGamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">AccType</span><span class="w"> </span><span class="n">eps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e-9</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">sharedBytes</span><span class="p">[];</span><span class="w"></span>
<span class="w">  </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="p">)</span><span class="n">sharedBytes</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">AccType</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">sum_adj</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">shared</span><span class="p">;</span><span class="w">                   </span><span class="c1">// sum of gradient coming in</span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">sum_adj_l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w">     </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// sum of gradient coming in times layerNorm from value</span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">sum_x</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// sum of input value x</span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">sum_sqr</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// sum of (x - mean)^2</span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xRow</span><span class="w">   </span><span class="o">=</span><span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">yRow</span><span class="w">   </span><span class="o">=</span><span class="w">   </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adjRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">sum_x</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">sum_adj</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">sum_adj_l</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">sum_sqr</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">xv</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">xRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">yv</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">yRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">betav</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">beta</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.f</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">gammav</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">gamma</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">adjv</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">adjRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">lv</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">yv</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">betav</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">gammav</span><span class="p">;</span><span class="w"> </span><span class="c1">// go back to LN(x) from scaled and shifted version for accumulation</span>

<span class="w">          </span><span class="n">sum_x</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w">     </span><span class="o">+=</span><span class="w"> </span><span class="n">xv</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">sum_adj_l</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">adjv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lv</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">sum_adj</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w">   </span><span class="o">+=</span><span class="w"> </span><span class="n">adjv</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">sum_x</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w">     </span><span class="o">+=</span><span class="w"> </span><span class="n">sum_x</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w">     </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"> </span><span class="c1">// Accumulates in AccType</span>
<span class="w">          </span><span class="n">sum_adj</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w">   </span><span class="o">+=</span><span class="w"> </span><span class="n">sum_adj</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w">   </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"> </span><span class="c1">// Accumulates in AccType</span>
<span class="w">          </span><span class="n">sum_adj_l</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sum_adj_l</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"> </span><span class="c1">// Accumulates in AccType</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="w"> </span><span class="n">mean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">xv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xv</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mean</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">sum_sqr</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ex</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="n">sum_sqr</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sum_sqr</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"> </span><span class="c1">// Accumulates in AccType</span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="w"> </span><span class="n">sigma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sum_sqr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">eps</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Jacobian of layer norm</span>
<span class="w">      </span><span class="c1">// J = [ \frac{1}{N\sigma} (N\delta_{ij} - l_i l_j - 1) ]_{ij}</span>
<span class="w">      </span><span class="c1">// J * a = dC/dx_i = ( N a_i - l_i \sum_j l_j a_j - \sum_j a_j ) / (N \sigma)</span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">xv</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">xRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">gammav</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">gamma</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">adjv</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">adjRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">lv</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">xv</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mean</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sigma</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">gradLv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adjv</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">lv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sum_adj_l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum_adj</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">gradLv</span><span class="w">        </span><span class="o">/=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sigma</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">gradXv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gammav</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gradLv</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// Keep LN gradient between [-1000, 1000] for TensorOps, this currently used for making values fit into fp16. This wil also clip inf.</span>
<span class="w">          </span><span class="c1">// @TODO: to be fixed and removed.</span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">sgn</span><span class="p">(</span><span class="n">gradXv</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">cutoff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">1000.f</span><span class="p">;</span><span class="w"> </span><span class="c1">// @TODO: expose this somehow as an option? or better: make obsolete.</span>
<span class="w">          </span><span class="n">gradXv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">abs</span><span class="p">(</span><span class="n">gradXv</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">cutoff</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">sign</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cutoff</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">gradXv</span><span class="p">;</span><span class="w"> </span><span class="c1">// if gradXv is NaN the value return is NaN too because NaN &gt; value is false.</span>

<span class="w">          </span><span class="c1">// @TODO: frankly, this is embarrasing and should rather be removed or optional? It does help for low precision computation though. Maybe turn into option?</span>
<span class="w">          </span><span class="n">gradXv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isnan</span><span class="p">(</span><span class="n">gradXv</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mf">0.f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">gradXv</span><span class="p">;</span><span class="w"> </span><span class="c1">// turn NaN into 0.</span>

<span class="w">          </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gradXRow</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">gradX</span><span class="w">     </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">gradXRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w">    </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="n">gradXv</span><span class="p">);</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gradGammaRow</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">gradGamma</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="c1">// assignment is correct here as this gets summed up</span>
<span class="w">          </span><span class="c1">// in the next kernel via matrix product</span>
<span class="w">          </span><span class="n">gradGammaRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="n">adjv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lv</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">LayerNormalizationGrad</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allocator</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gradX</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gradGamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gradBeta</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">Tensor</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">Tensor</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">Tensor</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="kt">float</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tempGradGammaMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">Tensor</span><span class="w"> </span><span class="n">tempGradGamma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorBase</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">tempGradGammaMemory</span><span class="p">,</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getBackend</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">tempGradGamma</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="mf">0.f</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tempOnesMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">rows</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeOf</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="n">Tensor</span><span class="w"> </span><span class="n">tempOnes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorBase</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">tempOnesMemory</span><span class="p">,</span><span class="w"> </span><span class="n">Shape</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">}),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getBackend</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">tempOnes</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="mf">1.f</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">gradX</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">gLayerNormalizationGrad</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">gradX</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">tempGradGamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">x</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">gamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">beta</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">eps</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">gradX</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// accumulate in float</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">gLayerNormalizationGrad</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">gradX</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">tempGradGamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">x</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">gamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">beta</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">eps</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;LayerNormalizationGrad not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">gradX</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// We use this go get rid of the atomicAdd and perform a reduce of the gradients afterwards.</span>
<span class="w">  </span><span class="c1">// This is much faster for fp16 which seems to have a broken atomicAdd implementation.</span>
<span class="w">  </span><span class="c1">// We reduce bias gradients with a matrix multiply, but use a 32-bit compute type.</span>
<span class="w">  </span><span class="c1">// This preserves precision with larger batches where all batch entries reduce into a single vector.</span>
<span class="w">  </span><span class="c1">// See also AffineNodeOp where we do the same for biases</span>
<span class="w">  </span><span class="n">gpu</span><span class="o">::</span><span class="n">Prod</span><span class="p">(</span><span class="n">gradGamma</span><span class="p">,</span><span class="w"> </span><span class="n">tempOnes</span><span class="p">,</span><span class="w"> </span><span class="n">tempGradGamma</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">);</span><span class="w"> </span><span class="c1">// beta set to one to add</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">gradBeta</span><span class="p">)</span><span class="w"> </span><span class="c1">// dC/dbeta = adj - inverse broadcasting (reduction)</span>
<span class="w">    </span><span class="n">gpu</span><span class="o">::</span><span class="n">Prod</span><span class="p">(</span><span class="n">gradBeta</span><span class="p">,</span><span class="w"> </span><span class="n">tempOnes</span><span class="p">,</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">);</span><span class="w"> </span><span class="c1">// beta set to one to add</span>

<span class="w">  </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">tempGradGammaMemory</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">tempOnesMemory</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gRMSNormalization</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">AccType</span><span class="w"> </span><span class="n">eps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e-9</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">_sharedBytes</span><span class="p">[];</span><span class="w"></span>
<span class="w">  </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_shareAccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="p">)</span><span class="n">_sharedBytes</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">AccType</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">yRow</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xRow</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">_sqSum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_shareAccType</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">_sqSum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">xv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">xRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">_sqSum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">xv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">xv</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="n">_sqSum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_sqSum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="w"> </span><span class="n">rms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_sqSum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">eps</span><span class="p">);</span><span class="w"> </span><span class="c1">// all AccType</span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">gammav</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">gamma</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">xv</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">xRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">betav</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">beta</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.f</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">rmsNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xv</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">rms</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">y</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">gammav</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rmsNorm</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">betav</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">yRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">RMSNormalization</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">Tensor</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="kt">float</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gRMSNormalization</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                                 </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                                 </span><span class="n">gamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                                 </span><span class="n">beta</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">beta</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                                 </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                                 </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                                 </span><span class="n">eps</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gRMSNormalization</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                                </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                                </span><span class="n">gamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                                                </span><span class="n">beta</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">beta</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                                </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                                </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                                </span><span class="n">eps</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;RMSNormalization not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gRMSNormalizationGrad</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gradX</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gradGamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">AccType</span><span class="w"> </span><span class="n">eps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e-9</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">sharedBytes</span><span class="p">[];</span><span class="w"></span>
<span class="w">  </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="o">*</span><span class="p">)</span><span class="n">sharedBytes</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">AccType</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">sum_adj_r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared</span><span class="p">;</span><span class="w">  </span><span class="c1">// sum of gradient coming in times layerNorm from value</span>
<span class="w">      </span><span class="n">AccType</span><span class="o">*</span><span class="w"> </span><span class="n">sum_sqr</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// sum of x^2</span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xRow</span><span class="w">   </span><span class="o">=</span><span class="w">   </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">yRow</span><span class="w">   </span><span class="o">=</span><span class="w">   </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adjRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="n">sum_adj_r</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">sum_sqr</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.0f</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">xv</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">xRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">yv</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">yRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">betav</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">beta</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">0.f</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">gammav</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">gamma</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">adjv</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">adjRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">rv</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">yv</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">betav</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">gammav</span><span class="p">;</span><span class="w"> </span><span class="c1">// go back to RMSNorm(x) from scaled and shifted version for accumulation</span>

<span class="w">          </span><span class="n">sum_adj_r</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">adjv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rv</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">sum_sqr</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w">   </span><span class="o">+=</span><span class="w"> </span><span class="n">xv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">xv</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">sum_adj_r</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sum_adj_r</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"> </span><span class="c1">// Accumulates in AccType</span>
<span class="w">          </span><span class="n">sum_sqr</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w">   </span><span class="o">+=</span><span class="w"> </span><span class="n">sum_sqr</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w">   </span><span class="o">+</span><span class="w"> </span><span class="n">skip</span><span class="p">];</span><span class="w"> </span><span class="c1">// Accumulates in AccType</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">AccType</span><span class="w"> </span><span class="n">rms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sum_sqr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">eps</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Jacobian of RMS norm</span>
<span class="w">      </span><span class="c1">// J = [ \frac{1}{N * rms} (N\delta_{ij} - RN_i RN_j) ]_{ij}</span>
<span class="w">      </span><span class="c1">// J * a = dC/dx_i = ( N a_i - RN_i \sum_j RN_j a_j ) / (N * rms)</span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">xv</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">xRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">gammav</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="n">gamma</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">adjv</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">adjRow</span><span class="p">[</span><span class="n">id</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">rmsNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xv</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">rms</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">gradNorm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adjv</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">rmsNorm</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sum_adj_r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">          </span><span class="n">gradNorm</span><span class="w">        </span><span class="o">/=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rms</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">gradXv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gammav</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gradNorm</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// Keep RMSN gradient between [-1000, 1000] for TensorOps, this currently used for making values fit into fp16. This wil also clip inf.</span>
<span class="w">          </span><span class="c1">// @TODO: to be fixed and removed.</span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">sgn</span><span class="p">(</span><span class="n">gradXv</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">AccType</span><span class="w"> </span><span class="n">cutoff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AccType</span><span class="p">)</span><span class="mf">1000.f</span><span class="p">;</span><span class="w"> </span><span class="c1">// @TODO: expose this somehow as an option? or better: make obsolete.</span>
<span class="w">          </span><span class="n">gradXv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">AccType</span><span class="o">&gt;::</span><span class="n">abs</span><span class="p">(</span><span class="n">gradXv</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">cutoff</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">sign</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cutoff</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">gradXv</span><span class="p">;</span><span class="w"> </span><span class="c1">// if gradXv is NaN the value return is NaN too because NaN &gt; value is false.</span>

<span class="w">          </span><span class="c1">// @TODO: frankly, this is embarrasing and should rather be removed or optional? It does help for low precision computation though. Maybe turn into option?</span>
<span class="w">          </span><span class="n">gradXv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isnan</span><span class="p">(</span><span class="n">gradXv</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mf">0.f</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">gradXv</span><span class="p">;</span><span class="w"> </span><span class="c1">// turn NaN into 0.</span>

<span class="w">          </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gradXRow</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">gradX</span><span class="w">     </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">gradXRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w">    </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="n">gradXv</span><span class="p">);</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">gradGammaRow</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">gradGamma</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="c1">// assignment is correct here as this gets summed up</span>
<span class="w">          </span><span class="c1">// in the next kernel via matrix product</span>
<span class="w">          </span><span class="n">gradGammaRow</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="n">adjv</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rmsNorm</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">RMSNormalizationGrad</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allocator</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gradX</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gradGamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gradBeta</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">Tensor</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">Tensor</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">Tensor</span><span class="w"> </span><span class="n">gamma</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">Tensor</span><span class="w"> </span><span class="n">beta</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">float</span><span class="w"> </span><span class="n">eps</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">-1</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tempGradGammaMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">Tensor</span><span class="w"> </span><span class="n">tempGradGamma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorBase</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">tempGradGammaMemory</span><span class="p">,</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getBackend</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">tempGradGamma</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="mf">0.f</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tempOnesMemory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">rows</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sizeOf</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="n">Tensor</span><span class="w"> </span><span class="n">tempOnes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TensorBase</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">tempOnesMemory</span><span class="p">,</span><span class="w"> </span><span class="n">Shape</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">}),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">(),</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getBackend</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">tempOnes</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="mf">1.f</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">gradX</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">gRMSNormalizationGrad</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">gradX</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">tempGradGamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">x</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">gamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">beta</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">eps</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">gradX</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// accumulate in float</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">gRMSNormalizationGrad</span><span class="o">&lt;</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">gradX</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">tempGradGamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">x</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">gamma</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">beta</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">cols</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">eps</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;RMSNormalizationGrad not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">gradX</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// We use this go get rid of the atomicAdd and perform a reduce of the gradients afterwards.</span>
<span class="w">  </span><span class="c1">// This is much faster for fp16 which seems to have a broken atomicAdd implementation.</span>
<span class="w">  </span><span class="c1">// We reduce bias gradients with a matrix multiply, but use a 32-bit compute type.</span>
<span class="w">  </span><span class="c1">// This preserves precision with larger batches where all batch entries reduce into a single vector.</span>
<span class="w">  </span><span class="c1">// See also AffineNodeOp where we do the same for biases</span>
<span class="w">  </span><span class="n">gpu</span><span class="o">::</span><span class="n">Prod</span><span class="p">(</span><span class="n">gradGamma</span><span class="p">,</span><span class="w"> </span><span class="n">tempOnes</span><span class="p">,</span><span class="w"> </span><span class="n">tempGradGamma</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">);</span><span class="w"> </span><span class="c1">// beta set to one to add</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">gradBeta</span><span class="p">)</span><span class="w"> </span><span class="c1">// dC/dbeta = adj - inverse broadcasting (reduction)</span>
<span class="w">    </span><span class="n">gpu</span><span class="o">::</span><span class="n">Prod</span><span class="p">(</span><span class="n">gradBeta</span><span class="p">,</span><span class="w"> </span><span class="n">tempOnes</span><span class="p">,</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">);</span><span class="w"> </span><span class="c1">// beta set to one to add</span>

<span class="w">  </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">tempGradGammaMemory</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">tempOnesMemory</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gShift</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">float</span><span class="w"> </span><span class="n">padValue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">add</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">padValue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">Shift</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">marian</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">shift</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="kt">float</span><span class="w"> </span><span class="n">padValue</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="kt">bool</span><span class="w"> </span><span class="n">invert</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">shift</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;bad dimensions&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// BUGBUG: This can only shift along the first axis. Shifting, e.g., along the</span>
<span class="w">  </span><span class="c1">// last axis cannot be implemented this way.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shift</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">stride</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">invert</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">offset</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gShift</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">padValue</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gShift</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">padValue</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Shift not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">ShiftGrad</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">marian</span><span class="o">::</span><span class="n">Shape</span><span class="w"> </span><span class="n">shift</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">invert</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ABORT_IF</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">shift</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;bad dimensions&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// BUGBUG: This can only shift along the first axis. Shifting, e.g., along the</span>
<span class="w">  </span><span class="c1">// last axis cannot be implemented this way.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shift</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">stride</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">invert</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">offset</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gShift</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">);</span><span class="w"> </span><span class="c1">// @TODO: What about padValue?</span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gShift</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">        </span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="mf">0.f</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Shift not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gSetSparse</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">values</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">SetSparse</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">indices</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indices</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">d_indices</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">CUDA_CHECK</span><span class="p">(</span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_indices</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="n">CUDA_CHECK</span><span class="p">(</span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_indices</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">indices</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                        </span><span class="n">length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">),</span><span class="w"></span>
<span class="w">                        </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">d_values</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">CUDA_CHECK</span><span class="p">(</span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_values</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="n">CUDA_CHECK</span><span class="p">(</span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">d_values</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="n">gSetSparse</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">d_indices</span><span class="p">,</span><span class="w"> </span><span class="n">d_values</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_indices</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_values</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/******************************************************************************/</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gLSTMCellForward</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">cell</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xW</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">mask</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xWrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xW</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sUrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sU</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">gf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">gi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">tanh</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">l</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gf</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rowCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">gi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gc</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rowCell</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">LSTMCellForward</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">gLSTMCellForward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                                </span><span class="c1">// output</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// cell state</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// xW</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// sU</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// b</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// mask</span>
<span class="w">      </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLSTMCellForward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                                </span><span class="c1">// output</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// cell state</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// xW</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// sU</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// b</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// mask</span>
<span class="w">      </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;LSTMCellForward not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gLSTMOutputForward</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">cell</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xW</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xWrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xW</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sUrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sU</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span><span class="w"></span>
<span class="w">          </span><span class="n">rowOut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">tanh</span><span class="p">(</span><span class="n">rowCell</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">LSTMOutputForward</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLSTMOutputForward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">        </span><span class="c1">// output</span>
<span class="w">                                            </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">  </span><span class="c1">// cell state</span>
<span class="w">                                            </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">  </span><span class="c1">// xW</span>
<span class="w">                                            </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">  </span><span class="c1">// sU</span>
<span class="w">                                            </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">  </span><span class="c1">// b</span>
<span class="w">                                            </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                            </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLSTMOutputForward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">        </span><span class="c1">// output</span>
<span class="w">                                            </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">  </span><span class="c1">// cell state</span>
<span class="w">                                            </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">  </span><span class="c1">// xW</span>
<span class="w">                                            </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">  </span><span class="c1">// sU</span>
<span class="w">                                            </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">  </span><span class="c1">// b</span>
<span class="w">                                            </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                            </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;gLSTMOutputForward not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gLSTMCellBackward</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outCell</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outXW</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outSU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outB</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">cell</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xW</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">mask</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"></span>

<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOutCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outCell</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOutXW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outXW</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOutSU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outSU</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xWrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xW</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sUrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sU</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowAdj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">gf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">gi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">gc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">tanh</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">l</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowAdj</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">          </span><span class="c1">// dc/dc_{t-1}</span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outCell</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gf</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// dc/d(b_f) = dc/d(xW_f) ...</span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">dcdxf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rowCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gf</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">gf</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outXW</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutXW</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dcdxf</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outSU</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutSU</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dcdxf</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outB</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">atomics</span><span class="o">::</span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">outB</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">dcdxf</span><span class="p">);</span><span class="w"> </span><span class="c1">// @TODO: get rid of atomicAdd everywhere!</span>

<span class="w">          </span><span class="c1">// dc/d(b_i) ...</span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">dcdb_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gc</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">gi</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outXW</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutXW</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dcdb_i</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outSU</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutSU</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dcdb_i</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outB</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">atomics</span><span class="o">::</span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">outB</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">dcdb_i</span><span class="p">);</span><span class="w"></span>

<span class="w">          </span><span class="c1">// dc/d(b_c) ...</span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">dcdxc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">gc</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gc</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outXW</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutXW</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dcdxc</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outSU</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutSU</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dcdxc</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outB</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">atomics</span><span class="o">::</span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">outB</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">dcdxc</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">LSTMCellBackward</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputs</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLSTMCellBackward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// state - adj</span>
<span class="w">      </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// xW - adj</span>
<span class="w">      </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// sU - adj</span>
<span class="w">      </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// b - adj</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// state</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// xW</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// sU</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// b</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// mask</span>
<span class="w">      </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLSTMCellBackward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// state - adj</span>
<span class="w">      </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// xW - adj</span>
<span class="w">      </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// sU - adj</span>
<span class="w">      </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">        </span><span class="c1">// b - adj</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// state</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// xW</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// sU</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                          </span><span class="c1">// b</span>
<span class="w">      </span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">inputs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// mask</span>
<span class="w">      </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">      </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;gLSTMCellBackward not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gLSTMOutputBackward</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outCell</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outXW</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outSU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outB</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">cell</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xW</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sU</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOutCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outCell</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOutXW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outXW</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowOutSU</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outSU</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">xWrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xW</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">sUrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sU</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">rowAdj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cols</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">xWrow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sUrow</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">tanh</span><span class="p">(</span><span class="n">rowCell</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>

<span class="w">          </span><span class="n">T</span><span class="w"> </span><span class="n">adj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowAdj</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">          </span><span class="c1">// dc/dc_{t-1}</span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outCell</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span><span class="w"></span>

<span class="w">          </span><span class="c1">// dc/d(b_o) = dc/d(xW_f) ...</span>
<span class="w">          </span><span class="kt">float</span><span class="w"> </span><span class="n">dcdxo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">go</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outXW</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutXW</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dcdxo</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outSU</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">rowOutSU</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dcdxo</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">outB</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">atomics</span><span class="o">::</span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">outB</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">dcdxo</span><span class="p">);</span><span class="w"> </span><span class="c1">// @TODO: get rid of atomicAdd</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">LSTMOutputBackward</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputs</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">back</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLSTMOutputBackward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// state - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// xW - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// sU - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// b - adj</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                    </span><span class="c1">// state</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                    </span><span class="c1">// xW</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                    </span><span class="c1">// sU</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                    </span><span class="c1">// b</span>
<span class="w">        </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gLSTMOutputBackward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// state - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// xW - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// sU - adj</span>
<span class="w">        </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="c1">// b - adj</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                    </span><span class="c1">// state</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                    </span><span class="c1">// xW</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                    </span><span class="c1">// sU</span>
<span class="w">        </span><span class="n">inputs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w">                    </span><span class="c1">// b</span>
<span class="w">        </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="n">rows</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">cols</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;gLSTMOutputBackward not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gHighwayForward</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in1</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in2</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">sigma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span><span class="w"></span>
<span class="w">      </span><span class="n">out</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in1</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sigma</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">in2</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sigma</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">HighwayForward</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in1</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in2</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gHighwayForward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in1</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in2</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gHighwayForward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in1</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">in2</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;HighwayForward not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gHighwayBackward</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out1</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">out2</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">outt</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in1</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">in2</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">sigma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">functional</span><span class="o">::</span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span><span class="w"></span>
<span class="w">      </span><span class="n">out1</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sigma</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">out2</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sigma</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="n">outt</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"></span>
<span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">sigma</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">((</span><span class="n">T</span><span class="p">)</span><span class="mf">1.f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sigma</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">in1</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">in2</span><span class="p">[</span><span class="n">index</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">HighwayBackward</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out1</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">Tensor</span><span class="w"> </span><span class="n">out2</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">Tensor</span><span class="w"> </span><span class="n">outt</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in1</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in2</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">out1</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">no</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out1</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">MAX_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out1</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gHighwayBackward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out1</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">out2</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">outt</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">in1</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">in2</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="cp">#if COMPILE_FP16</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">out1</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">float16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">gHighwayBackward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out1</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">out2</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">outt</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">in1</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">in2</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">half</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;HighwayForward not implemented for type {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">out1</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gMaxPoolingForward</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">int</span><span class="w"> </span><span class="n">outRows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">int</span><span class="w"> </span><span class="n">outCols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">int</span><span class="w"> </span><span class="n">inRows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">int</span><span class="w"> </span><span class="n">inCols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">int</span><span class="w"> </span><span class="n">numKernels</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">int</span><span class="w"> </span><span class="n">maskCols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">int</span><span class="w"> </span><span class="n">lastWidth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">tid</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">outRows</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">outCols</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rowId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">outRows</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">colId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">outRows</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">rowId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inCols</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">colId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">localMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">rowId</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">numKernels</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">maskCols</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">colId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">colId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">outRows</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lastWidth</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="n">currentMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">localMask</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">localMask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">currentMax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">currentMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">localMask</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">out</span><span class="p">[</span><span class="n">rowId</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">colId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">outCols</span><span class="p">)]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentMax</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">PoolingWithMaskingForward</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="n">Tensor</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="kt">bool</span><span class="w"> </span><span class="n">isEven</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">matchOrAbort</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_THREADS</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">inShape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">inRows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inShape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inShape</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">inCols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inShape</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">outShape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">outRows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">outCols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outShape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">outShape</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">lastWidth</span><span class="w"></span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">inCols</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">isEven</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">inCols</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">isEven</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">gMaxPoolingForward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">outRows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">outCols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">inRows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">inCols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">mask</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                          </span><span class="n">outShape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"></span>
<span class="w">                                          </span><span class="n">mask</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">2</span><span class="p">],</span><span class="w"></span>
<span class="w">                                          </span><span class="n">width</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">lastWidth</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gMaxPoolingBackward</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">adjRows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">adjCols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">adjIn</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">inRows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">inCols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">numKernels</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">maskCols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">lastWidth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">tid</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">adjRows</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adjCols</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rowId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">adjRows</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">colId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">adjRows</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">rowId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inCols</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">colId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">colId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">adjRows</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lastWidth</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">localMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">rowId</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">numKernels</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">maskCols</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">colId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">currentMaxIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">localMask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">currentMaxIdx</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">localMask</span><span class="p">[</span><span class="n">currentMaxIdx</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">currentMaxIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">adjIn</span><span class="p">[(</span><span class="n">rowId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inCols</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">colId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">currentMaxIdx</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="o">+=</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">rowId</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">colId</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adjCols</span><span class="p">)];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">PoolingWithMaskingBackward</span><span class="p">(</span><span class="n">Tensor</span><span class="w"> </span><span class="n">adj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">Tensor</span><span class="w"> </span><span class="n">adjIn</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">Tensor</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">bool</span><span class="w"> </span><span class="n">isEven</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">matchOrAbort</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">().</span><span class="n">elements</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">inShape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">inRows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inShape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inShape</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">inCols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inShape</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">adjShape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">adjRows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adjShape</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">adjCols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adjShape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">adjShape</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">lastWidth</span><span class="w"></span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">inCols</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">isEven</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">inCols</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">isEven</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">gMaxPoolingBackward</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">adj</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                           </span><span class="n">adjRows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                           </span><span class="n">adjCols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                           </span><span class="n">in</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                           </span><span class="n">adjIn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                           </span><span class="n">inRows</span><span class="p">,</span><span class="w"></span>
<span class="w">                                           </span><span class="n">inCols</span><span class="p">,</span><span class="w"></span>
<span class="w">                                           </span><span class="n">mask</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span><span class="w"></span>
<span class="w">                                           </span><span class="n">adjShape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"></span>
<span class="w">                                           </span><span class="n">mask</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="mi">2</span><span class="p">],</span><span class="w"></span>
<span class="w">                                           </span><span class="n">width</span><span class="p">,</span><span class="w"></span>
<span class="w">                                           </span><span class="n">lastWidth</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace gpu</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace marian</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Marian NMT Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>