<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Operations in the expression graph &mdash; Marian NMT v1.10.28 2022-01-28 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="canonical" href="http://marian-nmt.github.io/docs/api/operators.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Layers" href="layer.html" />
    <link rel="prev" title="Expression graphs" href="graph.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Marian NMT
          </a>
              <div class="version">
                v1.10.28
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="graph.html">Expression graphs</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Operations in the expression graph</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#operator-structure">Operator Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#expression-operator">Expression Operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#node-operator">Node Operator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#forward-operation">Forward operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#backward-operation">Backward Operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shape-and-type-changes">Shape and Type Changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functional-operator">Functional Operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tensor-operator">Tensor Operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#declared-specialization">Declared Specialization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="layer.html">Layers</a></li>
<li class="toctree-l1"><a class="reference internal" href="factors.html">Using Marian with factors</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/library_index.html">Library API</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">How to contribute to Marian</a></li>
<li class="toctree-l1"><a class="reference internal" href="doc_guide.html">Writing documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Marian NMT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Operations in the expression graph</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/operators.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="operations-in-the-expression-graph">
<h1>Operations in the expression graph<a class="headerlink" href="#operations-in-the-expression-graph" title="Permalink to this headline">¶</a></h1>
<p>Operations are responsible for manipulating the elements of an expression graph.
In Marian, many useful operations have already been implemented and can be found
the code documentation. The provided operations cover simple arithmetic, logical
comparisons and common mathematical functions; as well as tensor manipulation,
for example <code class="docutils literal notranslate"><span class="pre">slice</span></code> or <code class="docutils literal notranslate"><span class="pre">reshape</span></code>, and aggregations such as <code class="docutils literal notranslate"><span class="pre">sum</span></code> or <code class="docutils literal notranslate"><span class="pre">minimum</span></code>.
Finally, other routines, such as activation functions, useful in building
neutral networks are also available.</p>
<p>There are several necessary components required to implement an operation in
Marian’s expression graph. The highest-level component is the Expression
Operator, responsible for setting up the Node Operator and adding it to the
graph. Next, this Node Operator describes the nature of the forward and backward
operation to be performed. These operations are implemented using some
combination of Functional Operators (element wise), and Tensor Operators.</p>
<p>This overview aims to provide information about what each of the different
operator components does, how they fit together and where to go to make changes.
Then, equipped with this knowledge, to be able to add new functionality to
Marian.</p>
<section id="operator-structure">
<h2>Operator Structure<a class="headerlink" href="#operator-structure" title="Permalink to this headline">¶</a></h2>
<p>The central component in the graph is the <code class="docutils literal notranslate"><span class="pre">Chainable&lt;Tensor&gt;</span></code> object. This
object provides the abstract interface necessary to interact with elements in
the computation graph. The details of this interface can be found in
<a class="reference internal" href="api/file_src_graph_chainable.h.html#file-src-graph-chainable-h"><span class="std std-ref">/src/graph/chainable.h</span></a>. Note that the
template parameter corresponds to the underlying data structure, which in Marian
is the <code class="docutils literal notranslate"><span class="pre">Tensor</span></code>. Therefore, for convenience, the type <code class="docutils literal notranslate"><span class="pre">Expr</span></code> is defined:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">IPtr</span><span class="o">&lt;</span><span class="n">Chainable</span><span class="o">&lt;</span><span class="n">Tensor</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">Expr</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The implementation of the different operator components are divided across
several files:</p>
<ul class="simple">
<li><p>Expression Operator</p>
<ul>
<li><p><a class="reference internal" href="api/file_src_graph_expression_operators.h.html#file-src-graph-expression-operators-h"><span class="std std-ref">/src/graph/expression_operators.h</span></a></p></li>
<li><p><a class="reference internal" href="api/file_src_graph_expression_operators.cpp.html#file-src-graph-expression-operators-cpp"><span class="std std-ref">/src/graph/expression_operators.cpp</span></a></p></li>
</ul>
</li>
<li><p>Node Operator</p>
<ul>
<li><p><a class="reference internal" href="api/file_src_graph_node_operators_unary.h.html#file-src-graph-node-operators-unary-h"><span class="std std-ref">/src/graph/node_operators_unary.h</span></a></p></li>
<li><p><a class="reference internal" href="api/file_src_graph_node_operators_binary.h.html#file-src-graph-node-operators-binary-h"><span class="std std-ref">/src/graph/node_operators_binary.h</span></a></p></li>
<li><p><a class="reference internal" href="api/file_src_graph_node_operators_tuple.h.html#file-src-graph-node-operators-tuple-h"><span class="std std-ref">/src/graph/node_operators_tuple.h</span></a></p></li>
</ul>
</li>
<li><p>Functional Operator</p>
<ul>
<li><p><a class="reference internal" href="api/file_src_functional_operators.h.html#file-src-functional-operators-h"><span class="std std-ref">/src/functional/operators.h</span></a></p></li>
</ul>
</li>
<li><p>Tensor operation</p>
<ul>
<li><p><a class="reference internal" href="api/file_src_tensors_tensor_operators.h.html#file-src-tensors-tensor-operators-h"><span class="std std-ref">/src/tensors/tensor_operators.h</span></a></p></li>
<li><p><a class="reference internal" href="api/file_src_tensors_cpu_tensor_operators.cpp.html#file-src-tensors-cpu-tensor-operators-cpp"><span class="std std-ref">/src/tensors/cpu/tensor_operators.cpp</span></a></p></li>
<li><p><a class="reference internal" href="api/file_src_tensors_gpu_tensor_operators.cu.html#file-src-tensors-gpu-tensor-operators-cu"><span class="std std-ref">/src/tensors/gpu/tensor_operators.cu</span></a></p></li>
</ul>
</li>
<li><p>Declared Specialization</p>
<ul>
<li><p><a class="reference internal" href="api/program_listing_file_src_tensors_gpu_element.inc.html#program-listing-file-src-tensors-gpu-element-inc"><span class="std std-ref">/src/tensors/gpu/element.inc</span></a></p></li>
<li><p><a class="reference internal" href="api/program_listing_file_src_tensors_gpu_add.inc.html#program-listing-file-src-tensors-gpu-add-inc"><span class="std std-ref">/src/tensors/gpu/add.inc</span></a></p></li>
<li><p><a class="reference internal" href="api/program_listing_file_src_tensors_gpu_add_all.inc.html#program-listing-file-src-tensors-gpu-add-all-inc"><span class="std std-ref">/src/tensors/gpu/add_all.inc</span></a></p></li>
</ul>
</li>
</ul>
<p>To understand how the different components are inter-linked, we’ll look at each
of them in turn.</p>
</section>
<section id="expression-operator">
<h2>Expression Operator<a class="headerlink" href="#expression-operator" title="Permalink to this headline">¶</a></h2>
<p>The expression operator is the user-facing method used when building a graph. It
is responsible for constructing the corresponding Node Operation and inserting
it into the expression graph. To accommodate these core requirements, the
function <code class="docutils literal notranslate"><span class="pre">Expression</span></code> is able to perform both actions in generality:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">Expr</span><span class="w"> </span><span class="n">Expression</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Expr</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">graph</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This helper-function simplifies the definition of many expression operators. For
example, the implementation of the expression operator <code class="docutils literal notranslate"><span class="pre">sin(x)</span></code> is simply:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/graph/expression_operators.h</span>
<span class="n">Expr</span><span class="w"> </span><span class="nf">sin</span><span class="p">(</span><span class="n">Expr</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>

<span class="c1">// src/graph/expression_operators.cpp</span>
<span class="n">Expr</span><span class="w"> </span><span class="nf">sin</span><span class="p">(</span><span class="n">Expr</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Expression</span><span class="o">&lt;</span><span class="n">SinNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>However, implementations may perform actions beyond the core functionality
alone. Taking <code class="docutils literal notranslate"><span class="pre">sum</span></code> as an example</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Expr</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">Expr</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">()[</span><span class="n">ax</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Expression</span><span class="o">&lt;</span><span class="n">ReduceNodeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">ax</span><span class="p">,</span><span class="w"> </span><span class="n">ReduceNodeOpCode</span><span class="o">::</span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The trivial operation is handled without needing to construct a node operation.
This example also demonstrates a non-trivial construction of <code class="docutils literal notranslate"><span class="pre">ReduceNodeOp</span></code>,
which is capable of performing differing reduction operations depending on
instantiation.</p>
<p>Going further, an expression operator may be defined in terms of existing
expressions. Operators such as <code class="docutils literal notranslate"><span class="pre">weighted_average</span></code> are composed of three
different expression operator calls: <code class="docutils literal notranslate"><span class="pre">scalar_product</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, and <code class="docutils literal notranslate"><span class="pre">operator/</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Expr</span><span class="w"> </span><span class="nf">weighted_average</span><span class="p">(</span><span class="n">Expr</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="n">weights</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scalar_product</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">weights</span><span class="p">,</span><span class="w"> </span><span class="n">ax</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span><span class="w"> </span><span class="n">ax</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>While useful, composition at this level may be less efficient than lower-level
implementations.</p>
</section>
<section id="node-operator">
<h2>Node Operator<a class="headerlink" href="#node-operator" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Node</span></code> subclass of <code class="docutils literal notranslate"><span class="pre">Chainable&lt;Tensor&gt;</span></code> provides concrete implementations for
much of the abstract interface, while subclasses of <code class="docutils literal notranslate"><span class="pre">Node</span></code> enable different node
behaviours. In the context of operations, the relevant derived class is
<code class="docutils literal notranslate"><span class="pre">NaryNodeOp</span></code> and is base class used for Node Operators. This subclass provides
implementation focused on performing general N-arity operations. However, many
common operations are unary and, for convenience, a further specialization,
<code class="docutils literal notranslate"><span class="pre">UnaryNodeOp</span></code>, exists to simplify their definition.</p>
<p>The purpose of the Node Operator is to define the forward and backward behaviour
of the operation. The forward operation performs the desired operation while the
backward operation updates the gradients. These behaviours are written in terms
of <code class="docutils literal notranslate"><span class="pre">NodeOps</span></code>, where a <code class="docutils literal notranslate"><span class="pre">NodeOp</span></code> is a wrapper to define a capturing lambda
function. Explicitly these are defined as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/graph/chainable.h</span>
<span class="cp">#define NodeOp(op) [=]() { op; }</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">NodeOps</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Each <code class="docutils literal notranslate"><span class="pre">NodeOp</span></code> is written as a function in terms of the value (<code class="docutils literal notranslate"><span class="pre">val_</span></code>), gradient
(<code class="docutils literal notranslate"><span class="pre">adj_</span></code>) of the current node, and its children, via <code class="docutils literal notranslate"><span class="pre">child()</span></code>. The values and
gradients the n<sup>th</sup> child node are accessed via the interfaces
<code class="docutils literal notranslate"><span class="pre">child(n)-&gt;val()</span></code> and <code class="docutils literal notranslate"><span class="pre">child(n)-&gt;grad()</span></code>, respectively. NodeOps are executed in
order when running the graph forwards and backwards, as this snippet from <code class="docutils literal notranslate"><span class="pre">Node</span></code>
demonstrates</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Node in src/graph/node.h</span>
<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">runForward</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">NodeOps</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ops</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">op</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">runBackward</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">NodeOps</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ops</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ops</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">child</span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">trainable</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="n">op</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In backwards operation it is <strong>crucial</strong> that the <code class="docutils literal notranslate"><span class="pre">NopeOp</span></code> responsible for
propagating a gradient to <code class="docutils literal notranslate"><span class="pre">child(i)</span></code> is the i<sup>th</sup> element of the
NodeOps vector. The requirement that the child associated with the NodeOp be
trainable means that an out-of-position NodeOp may not be run. To represent no
operation a <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> can be passed as a NodeOp.</p>
<p>A typical node operator has the functionality demonstrated in the following
snippet.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// outline of a node op</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyNodeOp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">NaryNodeOp</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">MyNodeOp</span><span class="p">(</span><span class="n">Expr</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">NaryNodeOp</span><span class="p">({</span><span class="n">a</span><span class="p">},</span><span class="w"> </span><span class="n">newShape</span><span class="p">(...),</span><span class="w"> </span><span class="n">newType</span><span class="p">(...))</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="n">Shape</span><span class="w"> </span><span class="n">newShape</span><span class="p">(...)</span><span class="w"> </span><span class="p">{}</span><span class="w">  </span><span class="c1">// optional</span>
<span class="w">  </span><span class="n">Type</span><span class="w"> </span><span class="n">newType</span><span class="p">(...)</span><span class="w"> </span><span class="p">{}</span><span class="w">    </span><span class="c1">// optional</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;my_node_op&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">hash</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span><span class="w">          </span><span class="c1">// potentially required</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">equal</span><span class="p">(</span><span class="n">Expr</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span><span class="w">  </span><span class="c1">// potentially required</span>

<span class="w">  </span><span class="n">NodeOps</span><span class="w"> </span><span class="n">forwardOps</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="n">NodeOps</span><span class="w"> </span><span class="n">backwardOps</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>This outline describes a node operator that takes a single argument <code class="docutils literal notranslate"><span class="pre">a</span></code>. The
shape and type of the node would be determined by the result of <code class="docutils literal notranslate"><span class="pre">newShape</span></code> and
<code class="docutils literal notranslate"><span class="pre">newType</span></code> when constructing the <code class="docutils literal notranslate"><span class="pre">NaryNodeOp</span></code>. These functions represent any
custom logic used to determine the shape and type of the node. As indicated in
this example code, these are optional and, when omitted, calling
<code class="docutils literal notranslate"><span class="pre">NaryNodeOp({a})</span></code> would result in a node with the same shape and type as <code class="docutils literal notranslate"><span class="pre">a</span></code>.
The <code class="docutils literal notranslate"><span class="pre">type()</span></code> method returns the friendly name for the node. Note that the
<a class="reference external" href="https://onnx.ai">ONNX</a>
<a class="reference internal" href="api/program_listing_file_src_onnx_expression_graph_onnx_serialization.cpp.html#program-listing-file-src-onnx-expression-graph-onnx-serialization-cpp"><span class="std std-ref">interface</span></a>
maintains a mapping of these friendly names to their ONNX representation. In the
absence of any member variables the <code class="docutils literal notranslate"><span class="pre">hash()</span></code> and <code class="docutils literal notranslate"><span class="pre">equal()</span></code> methods can be
omitted, and defer to their <code class="docutils literal notranslate"><span class="pre">NaryNodeOp</span></code> definition. However, if such variables
exist then <code class="docutils literal notranslate"><span class="pre">hash()</span></code> should implement a hashed representation and <code class="docutils literal notranslate"><span class="pre">equal()</span></code>
should provide the necessary conditions to consider nodes equivalent. Finally,
the operations of the node are defined in <code class="docutils literal notranslate"><span class="pre">forwardOps()</span></code> and <code class="docutils literal notranslate"><span class="pre">backwardOps()</span></code>.</p>
<p>Continuing with the example of <code class="docutils literal notranslate"><span class="pre">sin(x)</span></code>, the code responsible for implementing
the behaviour is</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/graph/node_operators_unary.h</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SinNodeOp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">UnaryNodeOp</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">SinNodeOp</span><span class="p">(</span><span class="n">Expr</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">UnaryNodeOp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="n">NodeOps</span><span class="w"> </span><span class="n">forwardOps</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">functional</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">NodeOp</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">_2</span><span class="p">),</span><span class="w"> </span><span class="n">val_</span><span class="p">,</span><span class="w"> </span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">()))};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">NodeOps</span><span class="w"> </span><span class="n">backwardOps</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">functional</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">NodeOp</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="n">_1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">_2</span><span class="p">),</span><span class="w"> </span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">grad</span><span class="p">(),</span><span class="w"> </span><span class="n">adj_</span><span class="p">,</span><span class="w"> </span><span class="n">child</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">()))};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;sin&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>In this code, the constructor trivially initialises the <code class="docutils literal notranslate"><span class="pre">UnaryNodeOp</span></code>, passing
the expression <code class="docutils literal notranslate"><span class="pre">x</span></code> as its input. This propagates up to <code class="docutils literal notranslate"><span class="pre">NaryNodeOp</span></code> and becomes
<code class="docutils literal notranslate"><span class="pre">child(0)</span></code> of the node. The size and type of the SinNodeOp are equivalent to
that of <code class="docutils literal notranslate"><span class="pre">x</span></code>. The lack of any member variables allows the <code class="docutils literal notranslate"><span class="pre">hash()</span></code> and <code class="docutils literal notranslate"><span class="pre">equal()</span></code>
methods to be omitted. The friendly name for this node is the string <code class="docutils literal notranslate"><span class="pre">sin</span></code>. The
forward and backward implementation are accomplished using a single NodeOp each.</p>
<section id="forward-operation">
<h3>Forward operation<a class="headerlink" href="#forward-operation" title="Permalink to this headline">¶</a></h3>
<p>The forward NodeOp calls the tensor operation Element, that execute the
element-wise operation described by the functor:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">_2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The placeholders <code class="docutils literal notranslate"><span class="pre">_1</span></code>, <code class="docutils literal notranslate"><span class="pre">_2</span></code> are enabled by code in
<a class="reference internal" href="api/dir_src_functional.html#dir-src-functional"><span class="std std-ref">/src/functional</span></a> and interoperate with the
functional operators. In the call to <code class="docutils literal notranslate"><span class="pre">Element</span></code>, <code class="docutils literal notranslate"><span class="pre">val_</span></code> is assigned to <code class="docutils literal notranslate"><span class="pre">_1</span></code> and
<code class="docutils literal notranslate"><span class="pre">child(0)-&gt;val()</span></code> to <code class="docutils literal notranslate"><span class="pre">_2</span></code>. Therefore, this has the action of setting the
elements of this node to the result obtained by applying <code class="docutils literal notranslate"><span class="pre">sin</span></code> to the elements
of <code class="docutils literal notranslate"><span class="pre">child(0)</span></code>.</p>
</section>
<section id="backward-operation">
<h3>Backward Operation<a class="headerlink" href="#backward-operation" title="Permalink to this headline">¶</a></h3>
<p>The backward NodeOp is responsible for backpropagation of the gradients via
reverse-mode automatic differentiation. In this example, where <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">sin(x)</span></code>,
this corresponds to evaluating</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">dJ</span><span class="o">/</span><span class="n">dx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dJ</span><span class="o">/</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dy</span><span class="o">/</span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">dy</span><span class="o">/</span><span class="n">dx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>This is realised using the tensor operator <code class="docutils literal notranslate"><span class="pre">Add</span></code> with the functor</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">_1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">_2</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>In the call to <code class="docutils literal notranslate"><span class="pre">Add</span></code>, <code class="docutils literal notranslate"><span class="pre">adj_</span></code> is assigned to <code class="docutils literal notranslate"><span class="pre">_1</span></code> and <code class="docutils literal notranslate"><span class="pre">child(0)-&gt;val()</span></code> to <code class="docutils literal notranslate"><span class="pre">_2</span></code>.
Therefore, this functor represents <code class="docutils literal notranslate"><span class="pre">dJ/dy</span> <span class="pre">*</span> <span class="pre">dy/dx</span></code>: the product of the gradient
at the current node and the gradient of the operation. This value is then added
to the gradient of the child <code class="docutils literal notranslate"><span class="pre">child(0)-&gt;grad()</span></code> as required.</p>
</section>
<section id="shape-and-type-changes">
<h3>Shape and Type Changes<a class="headerlink" href="#shape-and-type-changes" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">newShape</span></code> and <code class="docutils literal notranslate"><span class="pre">newType</span></code> methods are just a suggestion of how custom logic
may be encapsulated where needed. However, in practice, many operations do not
require a change in shape or type. In these instances, the node inherits the
broadcasted shape of its children as well as their common type. An important
feature of the type deduction in <code class="docutils literal notranslate"><span class="pre">NaryNodeOp::commonType()</span></code> is that it
guarantees that all child nodes are of the same type.</p>
<p>There are few operations in Marian that require a type specification. Where they
do exist, they are often simple as the desired type is explicitly provided, or
is trivially deduced. An example of this is <code class="docutils literal notranslate"><span class="pre">CastNodeOp</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// CastNodeOp in src/graph/node_operators_unary.h</span>
<span class="n">CastNodeOp</span><span class="p">(</span><span class="n">Expr</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">UnaryNodeOp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</pre></div>
</div>
<p>The desired type is set explicitly in construction. A slightly different example
is that of <code class="docutils literal notranslate"><span class="pre">CSRDotNodeOp</span></code>. It has several child nodes which are a mixture of
<code class="docutils literal notranslate"><span class="pre">DataType</span></code> and <code class="docutils literal notranslate"><span class="pre">IndexType</span></code> and therefore do not share a common type. The
solution is to explicitly specify the relevant children to
<code class="docutils literal notranslate"><span class="pre">NaryNodeOp::commonType({...})</span></code>.</p>
<p>Shape modifying operations are more common. A simple example is the class of
operations performed by <code class="docutils literal notranslate"><span class="pre">ReduceNodeOp</span></code> which involve an aggregation process
along one axis of the Tensor. The output shape is determined by</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ReduceNodeOp in src/graph/node_operators_unary.h</span>
<span class="n">Shape</span><span class="w"> </span><span class="nf">newShape</span><span class="p">(</span><span class="n">Expr</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">axis</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Shape</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">axis_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shape</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="n">axis</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">shape</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">axis_</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">shape</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The output shape is the same as the input but with the processed axis is reduced
to a single element. Other use cases include transpose and slicing operations,
as well as tensor products.</p>
</section>
</section>
<section id="functional-operator">
<h2>Functional Operator<a class="headerlink" href="#functional-operator" title="Permalink to this headline">¶</a></h2>
<p>As the NodeOp are evaluated, they encounter the underlying datatype of the
<code class="docutils literal notranslate"><span class="pre">Tensor</span></code>. At this stage, type-specific intrinsic functions are required. These
intrinsics are implemented in the templated struct <code class="docutils literal notranslate"><span class="pre">Ops&lt;ElementType&gt;</span></code>, with a
specialization required for each type. The current required types are:</p>
<ul class="simple">
<li><p>float</p></li>
<li><p>double</p></li>
<li><p>float32x4 (see <code class="docutils literal notranslate"><span class="pre">src/3rd_party/sse_mathfun.h</span></code>)</p></li>
<li><p>float32x8 (see <code class="docutils literal notranslate"><span class="pre">src/3rd_party/avx_mathfun.h</span></code>)</p></li>
<li><p>half (see <code class="docutils literal notranslate"><span class="pre">cuda_fp16.h</span></code> in the CUDA Math API)</p></li>
</ul>
<p>Further details are available in
<a class="reference internal" href="api/file_src_common_types.h.html#file-src-common-types-h"><span class="std std-ref">/src/common/types.h</span></a>.</p>
<p>Returning to the example of <code class="docutils literal notranslate"><span class="pre">sin(x)</span></code>, the specialization for <code class="docutils literal notranslate"><span class="pre">float</span></code> and
<code class="docutils literal notranslate"><span class="pre">double</span></code> requires</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/functional/operators.h</span>
<span class="c1">// in namespace marian::functional</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Ops</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">HOST_DEVICE_INLINE</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">ABORT</span><span class="p">(</span><span class="s">&quot;Unknown type&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Specialization for float</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Ops</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">HOST_DEVICE_INLINE</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">sinf</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Specialization for double</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Ops</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">HOST_DEVICE_INLINE</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The remaining specializations can be seen in
<a class="reference internal" href="api/file_src_functional_operators.h.html#file-src-functional-operators-h"><span class="std std-ref">/src/functional/operators.h</span></a>. Note
that the general template must produce a runtime abort.</p>
<p>The final component of the functional operator is to call the macro that enables
interoperability with the framework of
<a class="reference internal" href="api/dir_src_functional.html#dir-src-functional"><span class="std std-ref">/src/functional</span></a>. For a unary operator, this is
the macro <code class="docutils literal notranslate"><span class="pre">UNARY</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">UNARY</span><span class="p">(</span><span class="n">Sin</span><span class="p">,</span><span class="w">     </span><span class="n">sin</span><span class="p">,</span><span class="w">        </span><span class="n">Ops</span><span class="o">&lt;</span><span class="n">ElementType</span><span class="o">&gt;::</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>where template parameter <code class="docutils literal notranslate"><span class="pre">ElementType</span></code> <strong>must</strong> be used. There are equivalent
macros for <code class="docutils literal notranslate"><span class="pre">BINARY</span></code> and <code class="docutils literal notranslate"><span class="pre">TERNARY</span></code> Ops.</p>
</section>
<section id="tensor-operator">
<h2>Tensor Operator<a class="headerlink" href="#tensor-operator" title="Permalink to this headline">¶</a></h2>
<p>Tensor operations use less abstracted interfaces to interact with the Tensors,
often working with the Tensor data directly. They also rely on BLAS (Basic
Linear Algebra Subprograms) libraries to accelerate these operations. As well as
libraries containing device-specific optimisations. These libraries include:</p>
<ul class="simple">
<li><p>CPU</p>
<ul>
<li><p>CBLAS / OpenBLAS</p></li>
<li><p>FBGEMM</p></li>
<li><p>INTGEMM</p></li>
<li><p>MKL</p></li>
</ul>
</li>
<li><p>GPU</p>
<ul>
<li><p>CUDA (cuBLAS)</p></li>
</ul>
</li>
</ul>
<p>An important subtlety is that while the CPU focused libraries use a row-major
representation, the cuBLAS library (GPU) instead uses a column-major
representation.</p>
<p>Furthermore, the OpenMPI and OpenMP libraries are employed for parallelisation.
While macros provided in
<a class="reference internal" href="api/file_src_common_definitions.h.html#file-src-common-definitions-h"><span class="std std-ref">/src/common/definitions.h</span></a> locally
enable faster floating-point math in supported compilers.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MARIAN_FFAST_MATH_BEGIN</span><span class="w"></span>
<span class="c1">// ffmath code</span>
<span class="n">MARIAN_FFAST_MATH_END</span><span class="w"></span>
</pre></div>
</div>
<p>The usual caveats apply when enabling <code class="docutils literal notranslate"><span class="pre">fast_math</span></code>, and can be found in
<a class="reference internal" href="api/file_src_common_definitions.h.html#file-src-common-definitions-h"><span class="std std-ref">/src/common/definitions.h</span></a></p>
<p>Tensor operators are declared in
<a class="reference internal" href="api/file_src_tensors_tensor_operators.h.html#file-src-tensors-tensor-operators-h"><span class="std std-ref">/src/tensors/tensor_operators.h</span></a>,
these are device-agnostic function that call the relevant device-specific
implementation. The CPU- and GPU-specific implementation are defined in <code class="docutils literal notranslate"><span class="pre">cpu</span></code>
namespace in <a class="reference internal" href="api/dir_src_tensors_cpu.html#dir-src-tensors-cpu"><span class="std std-ref">/src/tensors/cpu/</span></a> and the <code class="docutils literal notranslate"><span class="pre">gpu</span></code>
namespace <a class="reference internal" href="api/dir_src_tensors_gpu.html#dir-src-tensors-gpu"><span class="std std-ref">/src/tensors/gpu/</span></a>. Therefore a typical
operator defers to an implementation in the device-specific namespace.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">TensorOp</span><span class="p">(</span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="cp">#ifdef CUDA_FOUND</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">out</span><span class="o">-&gt;</span><span class="n">getBackend</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getDeviceId</span><span class="p">().</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">DeviceType</span><span class="o">::</span><span class="n">gpu</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">gpu</span><span class="o">::</span><span class="n">TensorOp</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">cpu</span><span class="o">::</span><span class="n">TensorOp</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>When compiled with GPU support, this function dispatches a call to the
implementation that corresponds to the backend device type configured in the
graph (either GPU or CPU). Without GPU support, only the CPU implementation is
available.</p>
<p>Many operations are covered by three general tensor operators: <code class="docutils literal notranslate"><span class="pre">Element</span></code>,
<code class="docutils literal notranslate"><span class="pre">Aggregate</span></code> and <code class="docutils literal notranslate"><span class="pre">Prod</span></code>. The <code class="docutils literal notranslate"><span class="pre">Element</span></code> operator applies a function element-wise
across an arbitrary number of input tensors and stores the result in the output
tensor. The <code class="docutils literal notranslate"><span class="pre">Aggregate</span></code> operator also applies a function element-wise across its
inputs, but instead aggregates the results in the output via a given aggregation
function. A common aggregation function used is addition, which is the basis of
the <code class="docutils literal notranslate"><span class="pre">Add</span></code> and <code class="docutils literal notranslate"><span class="pre">Reduce</span></code> operators. Finally, <code class="docutils literal notranslate"><span class="pre">Prod</span></code> deals with products of
tensors. This operator performs a general matrix multiplication with the
underlying implementation relying on the libraries mentioned above.</p>
<p>Specialized operators exist to manipulation tensors beyond the cases covered
above; such as under transposition and concatenation. These operators may even
be expressed in terms of existing tensor operators.</p>
<p>Furthermore, for complicated multi-operation computations, performance gains and
memory improvements may be realised by implementing a tensor operator for that
specific purpose. An example of this is <code class="docutils literal notranslate"><span class="pre">softmax</span></code>, which could be implemented
using multiple expression operators (<code class="docutils literal notranslate"><span class="pre">exp</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>), but is instead implemented
directly as a tensor operator. These optimized implementations may be device
specific.</p>
</section>
<section id="declared-specialization">
<h2>Declared Specialization<a class="headerlink" href="#declared-specialization" title="Permalink to this headline">¶</a></h2>
<p>The operations performed in the forward and backward methods of NodeOp require
their GPU templates to be explicitly declared. When a new specialization is
introduced without being explicitly instantiated it will cause a link error on
compilation:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>.../src/tensors/tensor_operators.h:41: undefined reference to `void marian::gpu::Element&lt;marian::functional::Assign&lt; ... &gt; ( ... )&#39;
</pre></div>
</div>
<p>To fix these undefined references, we must explicitly add the specialization to
the <code class="docutils literal notranslate"><span class="pre">.inc</span></code> files of <a class="reference internal" href="api/dir_src_tensors_gpu.html#dir-src-tensors-gpu"><span class="std std-ref">/src/tensors/gpu/</span></a>. Each
<code class="docutils literal notranslate"><span class="pre">.inc</span></code> file is included at the end of its corresponding <code class="docutils literal notranslate"><span class="pre">.cu</span></code> file, ensuring
that the specialization is compiled.</p>
<p>The undefined references should be added to the <code class="docutils literal notranslate"><span class="pre">.inc</span></code> file that corresponds to
the header file in which contains the declaration of the missing functions.</p>
<p>The file <a class="reference internal" href="api/file_src_tensors_gpu_element.inc.html#file-src-tensors-gpu-element-inc"><span class="std std-ref">element.inc</span></a> contains the
specializations of the function defined in
<a class="reference internal" href="api/file_src_tensors_gpu_element.h.html#file-src-tensors-gpu-element-h"><span class="std std-ref">element.h</span></a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/tensors/gpu/element.h</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Functor</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Tensors</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">Element</span><span class="p">(</span><span class="n">Functor</span><span class="w"> </span><span class="n">functor</span><span class="p">,</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensors</span><span class="p">...</span><span class="w"> </span><span class="n">tensors</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Similarly, <a class="reference internal" href="api/file_src_tensors_gpu_add.inc.html#file-src-tensors-gpu-add-inc"><span class="std std-ref">add.inc</span></a> contains the
specializations for functions matching either of the two signatures in
<a class="reference internal" href="api/file_src_tensors_gpu_add.h.html#file-src-tensors-gpu-add-h"><span class="std std-ref">add.h</span></a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/tensors/gpu/add.h</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Functor</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Tensors</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">Add</span><span class="p">(</span><span class="n">Functor</span><span class="w"> </span><span class="n">functor</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scale</span><span class="p">,</span><span class="w"> </span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensors</span><span class="p">...</span><span class="w"> </span><span class="n">tensors</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Functor</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">AggFunctor</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Tensors</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">Aggregate</span><span class="p">(</span><span class="n">Functor</span><span class="w"> </span><span class="n">functor</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">initAgg</span><span class="p">,</span><span class="w"> </span><span class="n">AggFunctor</span><span class="w"> </span><span class="n">aggFunctor</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scale</span><span class="p">,</span><span class="w"> </span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">Tensors</span><span class="p">...</span><span class="w"> </span><span class="n">tensors</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Finally <a class="reference internal" href="api/file_src_tensors_gpu_add_all.inc.html#file-src-tensors-gpu-add-all-inc"><span class="std std-ref">add_all.inc</span></a> contains the
specializations for <a class="reference internal" href="api/file_src_tensors_gpu_add_all.h.html#file-src-tensors-gpu-add-all-h"><span class="std std-ref">add_all.h</span></a>, which
are several versions of:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/tensors/gpu/add_all.h</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AccType</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Functor</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">AggFunctor</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">AggregateAll</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">allocator</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">Functor</span><span class="w"> </span><span class="n">functor</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">AccType</span><span class="w"> </span><span class="n">aggInit</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">AggFunctor</span><span class="w"> </span><span class="n">aggFunctor</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">AccType</span><span class="w"> </span><span class="n">scale</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">Tensor</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">Tensor</span><span class="w"> </span><span class="n">in1</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>However, for <a class="reference internal" href="api/file_src_tensors_gpu_add_all.h.html#file-src-tensors-gpu-add-all-h"><span class="std std-ref">add_all.h</span></a>, there is an
additional type dependence in the first template parameter, which requires two
entries:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">marian</span><span class="o">::</span><span class="n">gpu</span><span class="o">::</span><span class="n">AggregateAll</span><span class="o">&lt;</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">marian</span><span class="o">::</span><span class="n">gpu</span><span class="o">::</span><span class="n">AggregateAll</span><span class="o">&lt;</span><span class="w"> </span><span class="n">__half</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// for COMPILE_FP16</span>
</pre></div>
</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">__half</span></code> specialization is related to half-precision floats and should
be added to the <code class="docutils literal notranslate"><span class="pre">COMPILE_FP16</span></code> preprocessor block.</p>
<p>The simplest method to add the correct specialization is to take the compilation
error output and extract the needed signature. To extract the signature:</p>
<ol class="simple">
<li><p>Replace up to, and including, “undefined reference to `” with “template”</p></li>
<li><p>Replace the final ‘ with a semi-colon</p></li>
</ol>
<p>To conform with definitions in the codebase, we should replace
<code class="docutils literal notranslate"><span class="pre">IntrusivePtr&lt;marian::TensorBase&gt;</span></code> with its typedef <code class="docutils literal notranslate"><span class="pre">marian::Tensor</span></code>. Note that
as these files are included in <code class="docutils literal notranslate"><span class="pre">marian::gpu</span></code> namespace, and explicitly use
<code class="docutils literal notranslate"><span class="pre">marian::functional</span></code> namespace it is also possible to omit both of these
prefixes. Typically, the namespace prefix of the specialized function is removed
as well. Following these rules for the example of <code class="docutils literal notranslate"><span class="pre">SinNodeOp</span></code> results in the
following entries:</p>
<p><strong>element</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Element</span><span class="o">&lt;</span><span class="n">Assign</span><span class="o">&lt;</span><span class="n">Var</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">UnaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Sin</span><span class="p">,</span><span class="w"> </span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="n">Assign</span><span class="o">&lt;</span><span class="n">Var</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">UnaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Sin</span><span class="p">,</span><span class="w"> </span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">,</span><span class="w"> </span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>add</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Add</span><span class="o">&lt;</span><span class="n">BinaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Mult</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="n">UnaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Cos</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="k">class</span><span class="w"> </span><span class="nc">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">,</span><span class="k">class</span><span class="w"> </span><span class="nc">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="n">BinaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Mult</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="n">UnaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Cos</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="kt">float</span><span class="p">,</span><span class="k">class</span><span class="w"> </span><span class="nc">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">,</span><span class="k">class</span><span class="w"> </span><span class="nc">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">,</span><span class="k">class</span><span class="w"> </span><span class="nc">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>add_all</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">AggregateAll</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="kt">float</span><span class="p">,</span><span class="n">BinaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Mult</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="n">UnaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Cos</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="n">BinaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Plus</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">marian</span><span class="o">::</span><span class="n">Allocator</span><span class="o">&gt;</span><span class="p">,</span><span class="n">BinaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Mult</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="n">UnaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Cos</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="kt">float</span><span class="p">,</span><span class="n">BinaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Plus</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="kt">float</span><span class="p">,</span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">,</span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">,</span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">);</span><span class="w"></span>

<span class="cp">#if COMPILE_FP16</span>
<span class="k">template</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">AggregateAll</span><span class="o">&lt;</span><span class="n">__half</span><span class="p">,</span><span class="kt">float</span><span class="p">,</span><span class="n">BinaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Mult</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="n">UnaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Cos</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="n">BinaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Plus</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">marian</span><span class="o">::</span><span class="n">Allocator</span><span class="o">&gt;</span><span class="p">,</span><span class="n">BinaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Mult</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="n">UnaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Cos</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="kt">float</span><span class="p">,</span><span class="n">BinaryFunctor</span><span class="o">&lt;</span><span class="n">elem</span><span class="o">::</span><span class="n">Plus</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">,</span><span class="n">Assignee</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="p">,</span><span class="kt">float</span><span class="p">,</span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">,</span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">,</span><span class="n">marian</span><span class="o">::</span><span class="n">Tensor</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="graph.html" class="btn btn-neutral float-left" title="Expression graphs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="layer.html" class="btn btn-neutral float-right" title="Layers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Marian NMT Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>